<!DOCTYPE html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
--><html lang="zh" class="no-js">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Design_pattern - Newbee</title>
<meta name="description" content="">


  <meta name="author" content="Zhipeng Wang">
  
  <meta property="article:author" content="Zhipeng Wang">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="Newbee">
<meta property="og:title" content="Design_pattern">
<meta property="og:url" content="http://localhost:4000/design_pattern/">


  <meta property="og:description" content="">







  <meta property="article:published_time" content="2021-06-15T00:00:00+08:00">





  

  


<link rel="canonical" href="http://localhost:4000/design_pattern/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "ZhipengWang",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Newbee Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Newbee
          <span class="site-subtitle">sharing knowledge</span>
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/icons/bee.svg" alt="Zhipeng Wang" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Zhipeng Wang</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Software Engineer.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">SZ, CN.</span>
        </li>
      

      
        
          
        
          
        
          
        
          
        
          
        
          
        
      

      

      
        <li>
          <a href="mailto:wangzhipenghyc@163.com">
            <meta itemprop="email" content="wangzhipenghyc@163.com">
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Design_pattern">
    <meta itemprop="description" content="">
    <meta itemprop="datePublished" content="2021-06-15T00:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Design_pattern
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          38 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title">
<i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li>
<a href="#design-pattern">Design Pattern</a><ul>
<li>
<a href="#creational-patterns">Creational patterns</a><ul>
<li><a href="#abstract-factory">Abstract factory</a></li>
<li><a href="#builder">Builder</a></li>
<li><a href="#dependency-injection">Dependency Injection</a></li>
<li><a href="#factory-method">Factory method</a></li>
<li><a href="#lazy-initialization">Lazy Initialization</a></li>
<li><a href="#multiion">Multiion</a></li>
<li><a href="#object-pool">Object pool</a></li>
<li><a href="#prototype">Prototype</a></li>
<li><a href="#resource-acquisition-is-initialization">Resource acquisition is initialization</a></li>
<li><a href="#singleton">Singleton</a></li>
</ul>
</li>
<li>
<a href="#structural-patterns">Structural patterns</a><ul>
<li><a href="#adapter-wrapper-or-translator">Adapter, Wrapper, or Translator</a></li>
<li><a href="#bridge">Bridge</a></li>
<li><a href="#composite">Composite</a></li>
<li><a href="#decorator">Decorator</a></li>
<li><a href="#extension-object">Extension object</a></li>
<li><a href="#facade">Facade</a></li>
<li><a href="#flyweight">Flyweight</a></li>
<li><a href="#front-controller">Front controller</a></li>
<li><a href="#marker">Marker</a></li>
<li><a href="#module">Module</a></li>
<li><a href="#proxy">Proxy</a></li>
<li><a href="#twin">Twin</a></li>
</ul>
</li>
<li>
<a href="#behavioural-patterns">Behavioural patterns</a><ul>
<li><a href="#blackboard">Blackboard</a></li>
<li><a href="#chain-of-responsibility">Chain-of-responsibility</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#interpreter">Interpreter</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#mediator">Mediator</a></li>
<li><a href="#memento">Memento</a></li>
<li><a href="#observer">observer</a></li>
<li><a href="#state">state</a></li>
<li><a href="#strategy">Strategy</a></li>
<li><a href="#template">Template</a></li>
<li><a href="#vistor">vistor</a></li>
</ul>
</li>
<li>
<a href="#concurrency-pattern">Concurrency Pattern</a><ul>
<li><a href="#active-object">Active Object</a></li>
<li><a href="#double-checked-locking">Double-checked locking</a></li>
<li><a href="#monitor">Monitor</a></li>
<li><a href="#reactor">Reactor</a></li>
<li><a href="#thread-local-storage">Thread-local storage</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
</li></ul>

            </nav>
          </aside>
        
        <style type="text/css">
@import url("/assets/css/simple.css")
</style>

<h1 id="design-pattern">Design Pattern</h1>

<p>23 classification and list</p>

<h2 id="creational-patterns">Creational patterns</h2>

<h3 id="abstract-factory">Abstract factory</h3>
<p>抽象工厂模式，提供一个用于创建相关或依赖对象族的接口，而无需指定其具体类。</p>

<p><strong>使用场景</strong>：当一个场景需要引入多个接口，尤其是针对不同资源要绑定不同的对象时。例如：一个<code class="language-plaintext highlighter-rouge">player</code>加入战场的时候要分配装备，而且不同<code class="language-plaintext highlighter-rouge">阵营</code>的<code class="language-plaintext highlighter-rouge">player</code> 分配的装备型号不同。
<img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBGYWN0b3J5IHtcbkNyZWF0ZVRhbmsoKSBUYW5rXG5DcmVhdGVHdW4oKSBHdW5cbn1cbjw8aW50ZXJmYWNlPj4gRmFjdG9yeVxuJSUtXG5jbGFzcyBUYW5re1xuUnVuKClcbkZpcmUoKVxufVxuPDxpbnRlcmZhY2U-PiBUYW5rXG4lJS1cbmNsYXNzIEd1bntcblNob290KClcbn1cbjw8aW50ZXJmYWNlPj4gR3VuXG4lJS1cbmNsYXNzIHNvdmlldEZhY3Rvcnl7XG5DcmVhdGVUYW5rKCkgVGFua1xuQ3JlYXRlR3VuKCkgR3VuXG59XG4lJS1cbmNsYXNzIHQzNCB7XG4tdWludCBidWxsZXRcbi11aW50IGdhc1xuLXN0cmluZyBlbmdpbmVcblJ1bigpXG5GaXJlKClcbn1cbiUlLVxuY2xhc3MgYWs0NyB7XG4tdWludCBjbGlwXG5TaG9vdCgpXG59XG4lJS1cbmNsYXNzIGdlcm1hbnlGYWN0b3J5e1xuQ3JlYXRlVGFuaygpIFRhbmtcbkNyZWF0ZUd1bigpIEd1blxufVxuJSUtXG5jbGFzcyB0aWdlclRhbmt7XG4tdWludCBidWxsZXRcbi11aW50IGdhc1xuLXN0cmluZyBlbmdpbmVcblJ1bigpXG5GaXJlKClcbn1cbiUlLVxuY2xhc3MgbXA0MCB7XG4tdWludCBjbGlwXG5TaG9vdCgpXG59XG4lJS1cbkZhY3RvcnkgLi4-IFRhbmtcbkZhY3RvcnkgLi4-IEd1blxuJSUtXG5zb3ZpZXRGYWN0b3J5IC4ufD4gRmFjdG9yeVxuc292aWV0RmFjdG9yeSAuLj4gYWs0N1xuc292aWV0RmFjdG9yeSAuLj4gdDM0XG50MzQgLi58PiBUYW5rXG5hazQ3IC4ufD4gR3VuXG4lJS1cbmdlcm1hbnlGYWN0b3J5IC4ufD4gRmFjdG9yeVxuZ2VybWFueUZhY3RvcnkgLi4-IG1wNDBcbmdlcm1hbnlGYWN0b3J5IC4uPiB0aWdlclRhbmtcbnRpZ2VyVGFuayAuLnw-IFRhbmtcbm1wNDAgLi58PiBHdW4iLCJtZXJtYWlkIjpudWxsfQ"></p>

<p>调用方不需要了解实例化过程和接口对应的实现类，只要能<code class="language-plaintext highlighter-rouge">Tank</code>可以开、<code class="language-plaintext highlighter-rouge">Gun</code>可以射击，他只需要找到正确的<code class="language-plaintext highlighter-rouge">factory</code>。golang的示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Factory</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">CreateTank</span><span class="p">()</span> <span class="n">Tank</span>
    <span class="n">CreateGun</span><span class="p">()</span> <span class="n">Gun</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Tank</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Fire</span><span class="p">()</span>
    <span class="n">Run</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Gun</span><span class="p">()</span><span class="k">interface</span><span class="p">{</span>
    <span class="n">Shot</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">sovietFactory</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">sf</span> <span class="o">*</span><span class="n">sovietFactory</span><span class="p">)</span> <span class="n">CreateTank</span><span class="p">()</span> <span class="n">Car</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">t34</span><span class="p">{</span>
        <span class="n">gas</span><span class="o">:</span> <span class="m">700</span> 
        <span class="n">engine</span><span class="o">:</span> <span class="s">"t34"</span>
        <span class="n">bullet</span><span class="o">:</span> <span class="m">50</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">sf</span> <span class="o">*</span><span class="n">sovietFactory</span><span class="p">)</span> <span class="n">CreateGun</span><span class="p">()</span> <span class="n">Gun</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">ak47</span><span class="p">{</span>
        <span class="n">clip</span><span class="o">:</span> <span class="m">10000</span>
    <span class="p">}</span>
<span class="p">}</span> 

<span class="k">type</span> <span class="n">t34</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">gas</span> <span class="kt">uint64</span>
    <span class="n">bullet</span> <span class="kt">uint64</span>
    <span class="n">engine</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">t34</span><span class="p">)</span><span class="n">Run</span><span class="p">(){</span>
    <span class="n">t</span><span class="o">.</span><span class="n">gas</span><span class="o">--</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">t34</span><span class="p">)</span><span class="n">Fire</span><span class="p">(){</span>
    <span class="n">t</span><span class="o">.</span><span class="n">bullet</span><span class="o">--</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ak47</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">uint64</span> <span class="n">clip</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">akf7</span><span class="p">)</span><span class="n">Shot</span><span class="p">(){</span>
    <span class="n">a</span><span class="o">.</span><span class="n">clip</span><span class="o">--</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">germanyFactory</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">gf</span> <span class="o">*</span><span class="n">germanyFactory</span><span class="p">)</span> <span class="n">CreateTank</span><span class="p">()</span> <span class="n">Car</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">tigerTank</span><span class="p">{</span>
        <span class="n">gas</span><span class="o">:</span> <span class="m">1000</span>
        <span class="n">engine</span><span class="o">:</span> <span class="s">"tiger"</span>
        <span class="n">bullet</span><span class="o">:</span> <span class="m">60</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">gf</span> <span class="o">*</span><span class="n">germanyFactory</span><span class="p">)</span> <span class="n">CreateGun</span><span class="p">()</span> <span class="n">Gun</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">mp40</span><span class="p">{</span>
        <span class="n">clip</span><span class="o">:</span> <span class="m">8000</span>
    <span class="p">}</span>
<span class="p">}</span> 

<span class="k">type</span> <span class="n">tigerTank</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">gas</span> <span class="kt">uint64</span>
    <span class="n">bullet</span> <span class="kt">uint64</span>
    <span class="n">engine</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">tigerTank</span><span class="p">)</span><span class="n">Run</span><span class="p">(){</span>
    <span class="n">t</span><span class="o">.</span><span class="n">gas</span><span class="o">--</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">tigerTank</span><span class="p">)</span><span class="n">Fire</span><span class="p">(){</span>
    <span class="n">t</span><span class="o">.</span><span class="n">bullet</span><span class="o">--</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">mp40</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">uint64</span> <span class="n">clip</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">mp40</span><span class="p">)</span><span class="n">Shot</span><span class="p">(){</span>
    <span class="n">a</span><span class="o">.</span><span class="n">clip</span><span class="o">--</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">openFactory</span><span class="p">(</span><span class="n">power</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">Factory</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">power</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">`soviet`</span><span class="o">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sovietFactory</span><span class="p">{}</span>
        <span class="k">case</span> <span class="s">`germany`</span><span class="o">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">germanyFactory</span><span class="p">{}</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="no">nil</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">f</span>
<span class="p">}</span>

<span class="c">// caller</span>
<span class="k">if</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">openFactory</span><span class="p">(</span><span class="n">player</span><span class="o">.</span><span class="n">power</span><span class="p">);</span> <span class="n">f</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">tank</span> <span class="o">:=</span> <span class="n">f</span><span class="o">.</span><span class="n">CreateTank</span><span class="p">()</span>
    <span class="n">player</span><span class="o">.</span><span class="n">vehicle</span> <span class="o">=</span> <span class="n">tank</span>
    <span class="n">player</span><span class="o">.</span><span class="n">weapon</span><span class="o">.</span><span class="n">cannon</span> <span class="o">=</span> <span class="n">tank</span>
    <span class="n">player</span><span class="o">.</span><span class="n">weapon</span><span class="o">.</span><span class="n">gun</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">CreateGun</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这种设计模式的优缺点显而易见：</p>
<ul>
  <li>优点： 将对象的创建的具体流程与调用方完全屏蔽，调用方无需做额外工作，只要保证调用正确的factory就好了；</li>
  <li>缺点： 引入额外的封装代码，尤其当生产类型组合过多的时候，需要实现多种 factory。对调用方约束性较强，当调用方需要某些特性未暴露时，无法通过自己封装创建方法实现；</li>
</ul>

<h3 id="builder">Builder</h3>
<p>构建器模式，将复杂对象的构造与其表示分开，从而允许相同的构造过程创建各种表示。</p>

<p><strong>使用场景</strong>：适用于构造一些初始化可变选项特别多的对象，而其中一些选项对某个资源是相同的。例如：<code class="language-plaintext highlighter-rouge">player</code>在注册游戏时创建了一个<code class="language-plaintext highlighter-rouge">role</code>，同时还可以选择不同的职业加入战场。
<img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBSb2xlQnVpbGRlcntcbk5hbWUoKVxuUG93ZXIoKVxuR2VuZGVyKClcbkhlYWRlckltYWdlKClcbn1cbjw8aW50ZXJmYWNlPj4gUm9sZUJ1aWxkZXJcbiUlLVxuY2xhc3MgUm9sZXtcbm5hbWVcbnBvd2VyXG5nZW5kZXJcbmhlYWRJbWFnZVxuc2tpbGxcbnNwZWVkXG5saWZlVmFsdWVcblNob3coKVxufVxuJSUtXG5jbGFzcyBTcGVjaWFsU29sZGllcntcbk5hbWUoKVxuUG93ZXIoKVxuR2VuZGVyKClcbkhlYWRlckltYWdlKClcbkdldFJvbGUoKSBSb2xlXG59XG4lJS1cbmNsYXNzIEFybW9yZWRTb2xkaWVye1xuTmFtZSgpXG5Qb3dlcigpXG5HZW5kZXIoKVxuSGVhZGVySW1hZ2UoKVxuR2V0Um9sZSgpIFJvbGVcbn1cbiUlLVxuY2xhc3MgRGlyZWN0b3J7XG5idWlsZGVyIFJvbGVCdWlsZGVyXG5Db25zdHJ1Y3QoKVxufVxuJSUtXG5EaXJlY3RvciAuLm8gUm9sZUJ1aWxkZXJcblNwZWNpYWxTb2xkaWVyIC4uPiBSb2xlXG5Bcm1vcmVkU29sZGllciAuLj4gUm9sZVxuQXJtb3JlZFNvbGRpZXIgLi58PiBSb2xlQnVpbGRlclxuU3BlY2lhbFNvbGRpZXIgLi58PiBSb2xlQnVpbGRlciIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang 的示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Builder</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Name</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span>
    <span class="n">Power</span><span class="p">(</span><span class="n">power</span> <span class="kt">string</span><span class="p">)</span>
    <span class="n">Gender</span><span class="p">(</span><span class="n">gender</span> <span class="kt">string</span><span class="p">)</span>
    <span class="n">HeaderImage</span><span class="p">(</span><span class="n">headImage</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Role</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">name</span> <span class="kt">string</span>
    <span class="n">power</span> <span class="kt">string</span>
    <span class="n">gender</span> <span class="kt">string</span>
    <span class="n">headImage</span> <span class="kt">string</span>
    <span class="n">skill</span> <span class="kt">string</span>
    <span class="n">speed</span> <span class="kt">uint32</span>
    <span class="n">lifeValue</span> <span class="kt">uint64</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">Role</span><span class="p">)</span><span class="n">Show</span><span class="p">(){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">builder</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">Role</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">builder</span><span class="p">)</span> <span class="n">Name</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">){</span>
    <span class="n">b</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">builder</span><span class="p">)</span><span class="n">Power</span><span class="p">(</span><span class="n">power</span> <span class="kt">string</span><span class="p">){</span>
    <span class="n">b</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">power</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">builder</span><span class="p">)</span><span class="n">Gender</span><span class="p">(</span><span class="n">gender</span> <span class="kt">string</span><span class="p">){</span>
    <span class="n">b</span><span class="o">.</span><span class="n">gender</span> <span class="o">=</span> <span class="n">gender</span>
<span class="p">}</span>
 
<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">builder</span><span class="p">)</span><span class="n">HeaderImage</span><span class="p">(</span><span class="n">headImage</span> <span class="kt">string</span><span class="p">){</span>
    <span class="n">b</span><span class="o">.</span><span class="n">headImage</span> <span class="o">=</span> <span class="n">headImage</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">SpecialSoldier</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">builder</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ss</span> <span class="o">*</span><span class="n">SpecialSoldier</span><span class="p">)</span><span class="n">GetRole</span><span class="p">()(</span><span class="n">r</span> <span class="n">Role</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">role</span>
    <span class="n">r</span><span class="o">.</span><span class="n">skill</span> <span class="o">=</span> <span class="s">"everything"</span>
    <span class="n">r</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="m">50</span>
    <span class="n">r</span><span class="o">.</span><span class="n">lifeValue</span> <span class="o">=</span> <span class="m">150</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ArmoredSoldier</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">builder</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">as</span> <span class="o">*</span><span class="n">ArmoredSoldier</span><span class="p">)</span><span class="n">GetRole</span><span class="p">()(</span><span class="n">r</span> <span class="n">Role</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">as</span><span class="o">.</span><span class="n">role</span>
    <span class="n">r</span><span class="o">.</span><span class="n">skill</span> <span class="o">=</span> <span class="s">"driving tanks"</span>
    <span class="n">r</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="m">30</span>
    <span class="n">r</span><span class="o">.</span><span class="n">lifeValue</span> <span class="o">=</span> <span class="m">100</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Director</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">builder</span> <span class="n">RoleBuilder</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">Director</span><span class="p">)</span><span class="n">Construct</span><span class="p">(){</span>
    <span class="n">d</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="s">"panda"</span><span class="p">)</span>
    <span class="n">d</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">Gender</span><span class="p">(</span><span class="s">"male"</span><span class="p">)</span>
    <span class="n">d</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">Power</span><span class="p">(</span><span class="s">"China"</span><span class="p">)</span>
    <span class="n">d</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">HeadImage</span><span class="p">(</span><span class="s">"panda.icon"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewDirector</span><span class="p">(</span><span class="n">b</span> <span class="n">builder</span><span class="p">)</span> <span class="o">*</span><span class="n">Director</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Director</span><span class="p">{</span>
        <span class="n">builder</span><span class="o">:</span> <span class="n">builder</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// caller</span>
<span class="n">specialSoldier</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">SpecialSoldier</span><span class="p">{}</span>
<span class="n">NewDirector</span><span class="p">(</span><span class="n">specialSoldier</span><span class="p">)</span><span class="o">.</span><span class="n">Construct</span><span class="p">()</span>
<span class="n">pandaSpecSoldier</span> <span class="o">:=</span> <span class="n">specialSoldier</span><span class="o">.</span><span class="n">GetRole</span><span class="p">()</span>

<span class="n">armoredSoldier</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ArmoredSoldier</span><span class="p">{}</span>
<span class="n">NewDirector</span><span class="p">(</span><span class="n">armoredSoldier</span><span class="p">)</span><span class="o">.</span><span class="n">Construct</span><span class="p">()</span>
<span class="n">pandaArmSoldier</span> <span class="o">:=</span> <span class="n">armoredSoldier</span><span class="o">.</span><span class="n">GetRole</span><span class="p">()</span>
</code></pre></div></div>
<p>在上面的示例代码中利用<code class="language-plaintext highlighter-rouge">golang的组合特性</code>（*）减少重复性的代码。对于一个职业（<code class="language-plaintext highlighter-rouge">Special Soldier</code>、<code class="language-plaintext highlighter-rouge">Armored Soldier</code>等），无论是哪个用户，都可以获得相同属性的角色。</p>

<p>该设计模式的优缺点如下：</p>
<ul>
  <li>优点：调用方可以去按需修改对象内部的成员，控制构造流程；</li>
  <li>缺点：每一个种 Product 都要构造一个对应的 Builder，且必须是可变的。</li>
</ul>

<p>在<code class="language-plaintext highlighter-rouge">golang</code>中或其他语言中<code class="language-plaintext highlighter-rouge">Builder</code>还有一种常见的，也十分‘有趣的’使用方法：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Role</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">name</span> <span class="kt">string</span>
    <span class="n">power</span> <span class="kt">string</span>
    <span class="n">gender</span> <span class="kt">string</span>
    <span class="n">headImage</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">builder</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">Role</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">builder</span><span class="p">)</span><span class="n">Name</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span><span class="o">*</span><span class="n">builder</span><span class="p">{</span>
    <span class="n">b</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">b</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">builder</span><span class="p">)</span><span class="n">Power</span><span class="p">(</span><span class="n">power</span> <span class="kt">string</span><span class="p">)</span><span class="o">*</span><span class="n">builder</span><span class="p">{</span>
    <span class="n">b</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">power</span>
    <span class="k">return</span> <span class="n">b</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">builder</span><span class="p">)</span><span class="n">Gender</span><span class="p">(</span><span class="n">gender</span> <span class="kt">string</span><span class="p">)</span><span class="o">*</span><span class="n">builder</span><span class="p">{</span>
    <span class="n">b</span><span class="o">.</span><span class="n">gender</span> <span class="o">=</span> <span class="n">gender</span>
    <span class="k">return</span> <span class="n">b</span>
<span class="p">}</span>
 
<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">builder</span><span class="p">)</span><span class="n">HeaderImage</span><span class="p">(</span><span class="n">headImage</span> <span class="kt">string</span><span class="p">)</span><span class="o">*</span><span class="n">builder</span><span class="p">{</span>
    <span class="n">b</span><span class="o">.</span><span class="n">headImage</span> <span class="o">=</span> <span class="n">headImage</span>
    <span class="k">return</span> <span class="n">b</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">builder</span><span class="p">)</span><span class="n">GetRole</span><span class="p">()</span><span class="n">Role</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">Role</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">builder</span><span class="p">)</span><span class="n">Builder</span><span class="p">()</span> <span class="o">*</span><span class="n">builder</span><span class="p">{</span>
    <span class="nb">new</span> <span class="o">:=</span> <span class="o">*</span><span class="n">b</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nb">new</span>
<span class="p">}</span>

<span class="c">// caller</span>
<span class="n">builder</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">builder</span><span class="p">{}</span><span class="o">.</span><span class="n">Gender</span><span class="p">(</span><span class="s">"male"</span><span class="p">)</span><span class="o">.</span><span class="n">Power</span><span class="p">(</span><span class="s">"china"</span><span class="p">)</span>
<span class="n">panda</span> <span class="o">:=</span> <span class="n">builder</span><span class="o">.</span><span class="n">Builder</span><span class="p">()</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="s">"panda"</span><span class="p">)</span><span class="o">.</span><span class="n">HeadrImage</span><span class="p">(</span><span class="s">"panda.icon"</span><span class="p">)</span><span class="o">.</span><span class="n">GetRole</span><span class="p">()</span>
<span class="n">long</span> <span class="o">:=</span> <span class="n">builder</span><span class="o">.</span><span class="n">Builder</span><span class="p">()</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="s">"long"</span><span class="p">)</span><span class="o">.</span><span class="n">HeadrImage</span><span class="p">(</span><span class="s">"long.icon"</span><span class="p">)</span><span class="o">.</span><span class="n">GetRole</span><span class="p">()</span>
</code></pre></div></div>
<p>这种使用方法一定要注意，在<code class="language-plaintext highlighter-rouge">GetRole()</code>时返回一个结构体而不是结构体指针，否则构建新对象时容易对已经构造的对象造成污染。使用这种方法的好处是，可以通过‘继承’前一个<code class="language-plaintext highlighter-rouge">builder</code>，减少大量重复的成员变量赋值，而且也是并发安全的。</p>

<h3 id="dependency-injection">Dependency Injection</h3>
<p>依赖注入模式，类通过一个注入器来代替直接创建依赖的对象，是增加代码可扩展性常用的手段。</p>

<p><strong>使用场景</strong>：简单的说调用方的实现依赖于某个类或服务，该类或服务是它实现上的一个有效组成部分，需要在初始化或者某个流程步骤将依赖类的对象传递给调用方。例如：<code class="language-plaintext highlighter-rouge">player</code>在一个游戏中需要切换不同的游戏模式。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBQbGF5ZXJ7XG5zZXJ2aWNlIEdhbWVTZXJ2aWNlXG5Mb2dpbigpXG5TZXRTZXJ2aWNlKEdhbWVTZXJ2aWNlKVxufVxuJSUtXG5jbGFzcyBHYW1lU2VydmljZVNldHRlcntcblNldFNlcnZpY2UoR2FtZVNlcnZpY2UpXG59XG48PGludGVyZmFjZT4-IEdhbWVTZXJ2aWNlU2V0dGVyXG4lJS1cbmNsYXNzIEdhbWVTZXJ2aWNle1xuQXV0aCgpXG5TdGFydCgpXG59XG48PGludGVyZmFjZT4-IEdhbWVTZXJ2aWNlXG4lJS1cbmNsYXNzIExvY2FsU2VydmljZXtcbkF1dGgoKVxuU3RhcnQoKVxufVxuJSUtXG5jbGFzcyBPbmxpbmVTZXJ2aWNle1xuQXV0aCgpXG5TdGFydCgpXG59XG5Mb2NhbFNlcnZpY2UgLi58PiBHYW1lU2VydmljZVxuT25saW5lU2VydmljZSAuLnw-IEdhbWVTZXJ2aWNlXG5QbGF5ZXItLT5HYW1lU2VydmljZVxuR2FtZVNlcnZpY2VTZXR0ZXIuLj5HYW1lU2VydmljZVxuUGxheWVyLi58PkdhbWVTZXJ2aWNlU2V0dGVyIiwibWVybWFpZCI6bnVsbH0"></p>

<p>golang的示例代码如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">GameService</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Auth</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">passwd</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="n">Start</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">GameServiceSetter</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">SetService</span><span class="p">(</span><span class="n">srv</span> <span class="n">GameService</span><span class="p">)</span>   
<span class="p">}</span>

<span class="k">type</span> <span class="n">srvSetter</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">srv</span> <span class="n">GameService</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ss</span> <span class="o">*</span><span class="n">srvSetter</span><span class="p">)</span><span class="n">SetService</span><span class="p">(</span><span class="n">srv</span> <span class="n">GameService</span><span class="p">){</span>
    <span class="n">ss</span><span class="o">.</span><span class="n">srv</span> <span class="o">=</span> <span class="n">srv</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">player</span> <span class="n">Struct</span><span class="p">{</span>
    <span class="n">name</span> <span class="kt">string</span>
    <span class="n">passwd</span> <span class="kt">string</span>
    <span class="n">srvSetter</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">player</span><span class="p">)</span><span class="n">Login</span><span class="p">(){</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">srv</span> <span class="o">!=</span> <span class="no">nil</span><span class="p">{</span>
       <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">srv</span><span class="o">.</span><span class="n">Auth</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">passwd</span><span class="p">){</span>
           <span class="n">p</span><span class="o">.</span><span class="n">srv</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span>
       <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">LocalService</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">LocalService</span><span class="p">)</span> <span class="n">Auth</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">passwd</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{</span>
    <span class="c">// TODO</span>
    <span class="k">return</span> <span class="no">true</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">LocalService</span><span class="p">)</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// TODO</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">OnlineService</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">OnlineService</span><span class="p">)</span> <span class="n">Auth</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">passwd</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{</span>
    <span class="c">// TODO</span>
    <span class="k">return</span> <span class="no">true</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">OnlineService</span><span class="p">)</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// TODO</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">SelectService</span><span class="p">(</span><span class="n">mode</span> <span class="kt">string</span><span class="p">,</span><span class="n">s</span> <span class="n">GameServiceSetter</span><span class="p">){</span>
    <span class="k">switch</span> <span class="n">mode</span><span class="p">{</span>
    <span class="k">case</span> <span class="s">`online`</span><span class="o">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">SetService</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OnlineService</span><span class="p">{})</span>
    <span class="k">case</span> <span class="s">``</span><span class="o">:</span> 
        <span class="n">s</span><span class="o">.</span><span class="n">SetService</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LocalService</span><span class="p">{})</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="c">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// caller</span>
<span class="n">panda</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Player</span><span class="p">{</span><span class="n">name</span><span class="o">:</span><span class="s">"panda"</span><span class="p">,</span> <span class="n">passwd</span><span class="o">:</span><span class="s">"passwd"</span><span class="p">}</span>
<span class="n">SelectService</span><span class="p">(</span><span class="s">"online"</span><span class="p">,</span> <span class="n">panda</span><span class="p">)</span>
<span class="n">panda</span><span class="o">.</span><span class="n">Login</span><span class="p">()</span>
</code></pre></div></div>

<p>通常情况下<code class="language-plaintext highlighter-rouge">GameServiceSetter</code>这一层抽象是被省略的，经常被以下的模式替代：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">NewPalyer</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">srv</span> <span class="n">GameService</span><span class="p">)(</span><span class="n">p</span> <span class="o">*</span><span class="n">Player</span><span class="p">){</span>
    <span class="o">...</span>
    <span class="n">p</span><span class="o">.</span><span class="n">srv</span> <span class="o">=</span> <span class="n">srv</span>
<span class="p">}</span>

<span class="c">// OR</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Player</span><span class="p">)</span><span class="n">SetGameService</span><span class="p">(</span><span class="n">srv</span> <span class="n">GameService</span><span class="p">){</span>
    <span class="n">p</span><span class="o">.</span><span class="n">srv</span> <span class="o">=</span> <span class="n">srv</span>
<span class="p">}</span>

<span class="c">// OR</span>

<span class="k">type</span> <span class="n">Option</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">Player</span><span class="p">)</span> 

<span class="k">func</span> <span class="n">WithService</span><span class="p">(</span><span class="n">srv</span> <span class="n">GameService</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Player</span><span class="p">){</span>
        <span class="n">p</span><span class="o">.</span><span class="n">srv</span> <span class="o">=</span> <span class="n">srv</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewPlayer</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">ops</span> <span class="o">...</span> <span class="n">Option</span><span class="p">)(</span><span class="n">p</span> <span class="o">*</span><span class="n">Player</span><span class="p">){</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">op</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ops</span><span class="p">{</span>
        <span class="n">op</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>将 <code class="language-plaintext highlighter-rouge">GameServiceSetter</code> 单独的实现，通过组合（*）的方式放在结构体里面也不是必须的，多加一层抽象可以使代码迭代和扩展性上更好，但同时也会引起维护和理解上的困难。
以上替代方案中，第三种方案在 <code class="language-plaintext highlighter-rouge">golang package</code> 中对于接口的兼容和维护十分有效。</p>

<p>优缺点如下：</p>
<ul>
  <li>优点：在调用方对象的生命周期内，可以通过更换依赖的服务对象来进行模式切换，而不用关心底层具体实现；</li>
  <li>缺点：调用方要保障注入时机的可控性，否则可能调用一个未注册的空对象；</li>
</ul>

<h3 id="factory-method">Factory method</h3>
<p>工厂模式，定义用于创建单个对象的接口，将实例化创建部分放在子类实现，让子类决定实例化哪个类。</p>

<p><strong>使用场景</strong>：当获取的资源对象可以通过另一个对象构造和管理时，适合使用工厂模式。例如：<code class="language-plaintext highlighter-rouge">player</code>在<code class="language-plaintext highlighter-rouge">Game</code>中创建一个 <code class="language-plaintext highlighter-rouge">Room</code>，可以选择不同的对战模式。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBSb29te1xuK0pvaW4oKVxufVxuPDxpbnRlcmZhY2U-PiBSb29tXG4lJS1cbmNsYXNzIHB2cFJvb217XG4taW50IGNhcGFjaXR5XG4rSm9pbigpXG59XG4lJS1cbmNsYXNzIHB2Y1Jvb217XG4taW50IGNhcGFjaXR5XG4rSm9pbigpXG59XG4lJS1cbiUlIG1ha2VSb29tIGlzIDw8aW50ZXJmYWNlPj4gZnVuY3Rpb25cbmNsYXNzIEdhbWV7XG4tTGlzdH5Sb29tfiByb29tc1xuK09wZW5Sb29tKCkgUm9vbVxubWFrZVJvb20oKSogUm9vbVxufVxuJSUtXG5jbGFzcyBwdmNHYW1le1xubWFrZVJvb20oKSBSb29tXG59XG4lJS1cbmNsYXNzIHB2cEdhbWV7XG5tYWtlUm9vbSgpIFJvb21cbn1cbiUlLVxucHZjUm9vbSAuLnw-IFJvb21cbnB2Y0dhbWUuLj5wdmNSb29tXG5wdmNHYW1lLS18PkdhbWVcbnB2cFJvb20gLi58PiBSb29tXG5wdnBHYW1lLi4-cHZwUm9vbVxucHZwR2FtZS0tfD5HYW1lXG5HYW1lLi4-Um9vbSIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang的示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Room</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Join</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">pvcRoom</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">capacity</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span><span class="o">*</span> <span class="n">pvcRoom</span><span class="p">)</span><span class="n">Join</span><span class="p">(){</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">pvpRoom</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">capacity</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span><span class="o">*</span> <span class="n">pvpRoom</span><span class="p">)</span><span class="n">Join</span><span class="p">(){</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">roomMaker</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">makeRoom</span><span class="p">()</span> <span class="n">Room</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Game</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">rooms</span> <span class="p">[]</span><span class="n">Room</span>
    <span class="n">roomMaker</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">Game</span><span class="p">)</span><span class="n">OpenRoom</span><span class="p">()</span> <span class="n">Room</span><span class="p">{</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="n">g</span><span class="o">.</span><span class="n">makeRoom</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">rooms</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">rooms</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">pvpGame</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">pvp</span> <span class="o">*</span><span class="n">pvpGame</span><span class="p">)</span><span class="n">makeRoom</span><span class="p">(){</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">pvpRoom</span><span class="p">{</span><span class="n">capacity</span><span class="o">:</span> <span class="m">10</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">pvcGame</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">pvc</span> <span class="o">*</span><span class="n">pvcGame</span><span class="p">)</span><span class="n">makeRoom</span><span class="p">(){</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">pvcRoom</span><span class="p">{</span><span class="n">capacity</span><span class="o">:</span> <span class="m">5</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewPVPGame</span><span class="p">()</span> <span class="o">*</span><span class="n">Game</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Gmame</span><span class="p">{</span>
        <span class="n">roomMaker</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">pvpGame</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewPVCGame</span><span class="p">()</span> <span class="o">*</span><span class="n">Game</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Gmame</span><span class="p">{</span>
        <span class="n">roomMaker</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">pvcGame</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// caller</span>
<span class="n">pvpGame</span> <span class="o">:=</span> <span class="n">NewPVPGame</span><span class="p">()</span>
<span class="n">room</span> <span class="o">:=</span> <span class="n">pvpGame</span><span class="o">.</span><span class="n">OpenRoom</span><span class="p">()</span>
</code></pre></div></div>
<p>由于golang没有类似虚基类的语法特性，无法实现类图中所展示的关系，只能通过类似<code class="language-plaintext highlighter-rouge">Dependency Injection</code>的方式来模拟。</p>

<p>其优缺点如下：</p>
<ul>
  <li>优点：将类的构造与调用方隔离，实现解耦合。将底层具体类型的构造实现交给继承的子类，通过拓展子类就可以实现更多工厂类型；</li>
  <li>缺点：额外的封装增加开发成本，如果只是简单的几种类型，建议使用<code class="language-plaintext highlighter-rouge">switch</code>代替。</li>
</ul>

<h3 id="lazy-initialization">Lazy Initialization</h3>
<p>懒汉模式：将对象的创建，值的计算或其他昂贵的过程延迟到第一次使用时的策略。此模式在GoF目录中显示为“虚拟代理”，这是代理模式的一种实施策略。</p>

<p><strong>使用场景</strong>：当访问的资源比较昂贵，而资源又未必一定会被访问的情况下可以使用懒汉模式。例如：<code class="language-plaintext highlighter-rouge">player</code>在<code class="language-plaintext highlighter-rouge">Game</code>中请求开启了超清画质模式，该模式需要启动超高清计算引擎。</p>

<p>golang示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">var</span> <span class="p">(</span>
    <span class="n">lowGraphEngine</span> <span class="o">=</span> <span class="n">NewEngine</span><span class="p">(</span><span class="s">`lowlevel`</span><span class="p">)</span>
    <span class="n">commonGraphEngine</span> <span class="o">=</span> <span class="n">NewEngine</span><span class="p">(</span><span class="s">`common`</span><span class="p">)</span>
    <span class="n">highGraphEngine</span> <span class="n">Engine</span>
    <span class="n">once</span> <span class="n">sync</span><span class="o">.</span><span class="n">Once</span>
    <span class="n">nowEngine</span> <span class="n">Engine</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">SwitchEngine</span><span class="p">(</span><span class="n">engine</span> <span class="kt">string</span><span class="p">){</span>
    <span class="k">switch</span> <span class="n">engine</span><span class="p">{</span>
        <span class="k">case</span> <span class="s">`lowlevel`</span><span class="o">:</span>
            <span class="n">nowEngine</span><span class="o">=</span><span class="n">lowGraphEngine</span>
        <span class="k">case</span> <span class="s">`commonlevel`</span><span class="o">:</span>
            <span class="n">nowEngine</span><span class="o">=</span><span class="n">commonGraphEngine</span>
        <span class="k">case</span> <span class="s">`highlevel`</span><span class="o">:</span>
            <span class="c">// TODO: add lock</span>
            <span class="k">if</span> <span class="n">highGraphEngine</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
                <span class="n">highGraphEngine</span> <span class="o">=</span> <span class="n">NewEngine</span><span class="p">(</span><span class="s">`highlevel`</span><span class="p">)</span>
            <span class="p">}</span>
                
            <span class="n">nowEngine</span><span class="o">=</span><span class="n">highGraphEngine</span>
        <span class="k">default</span><span class="o">:</span> 
            <span class="c">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>  
</code></pre></div></div>

<p>如上示例代码所示，只有在选择开启<code class="language-plaintext highlighter-rouge">highlevel</code>时候才会去初始化 <code class="language-plaintext highlighter-rouge">highGraphEngine</code>，示例代码中没有加锁进行资源保护，并非多线程安全的，实际使用时要注意。</p>

<h3 id="multiion">Multiion</h3>

<h3 id="object-pool">Object pool</h3>
<p>对象池模式，经常在各种sdk中见到，主要作用是将资源池化，通过回收再利用的模式，避免频繁创建对象引入的消耗，同时也能减轻对象访问资源的压力。</p>

<p><strong>使用场景</strong>: 通过socket访问存储服务，调用远程http/https服务等。例如：游戏<code class="language-plaintext highlighter-rouge">client</code>与<code class="language-plaintext highlighter-rouge">server</code>频繁的进行数据交换。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBQb29sIHtcbi1MaXN0fkNsaWVudH4gcG9vbHNcbitHZXRDbGllbnQoKSBDbGllbnRcbitSZWN5bGVDbGllbnQoQ2xpZW50KVxufVxuJSUtXG5jbGFzcyBDbGllbnR7XG4rU2VuZCgpXG4rUmVjdigpXG59XG48PGludGVyZmFjZT4-IENsaWVudFxuJSUtXG5jbGFzcyBncnBjQ2xpZW50e1xuK1NlbmQoKVxuK1JlY3YoKVxufVxuJSUtXG5ncnBjQ2xpZW50Li58PkNsaWVudFxuUG9vbC4uPkNsaWVudCIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang的示例代码如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">type</span> <span class="n">Client</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Send</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span>
    <span class="n">Recv</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">grpcClient</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span> <span class="o">*</span><span class="n">grpcClient</span><span class="p">)</span><span class="n">Send</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">){</span>
    <span class="c">//TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span> <span class="o">*</span><span class="n">grpcClient</span><span class="p">)</span><span class="n">Recv</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">){</span>
    <span class="c">//TODO</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ClientPool</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">pools</span> <span class="k">chan</span> <span class="n">Client</span>
    <span class="n">conn</span> <span class="k">func</span><span class="p">()</span> <span class="p">(</span><span class="n">Client</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ClientPool</span><span class="p">)</span><span class="n">GetClient</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">)(</span><span class="n">c</span> <span class="n">Client</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">){</span>
    <span class="n">tCtx</span><span class="p">,</span> <span class="n">cancel</span> <span class="o">:=</span> <span class="n">context</span><span class="o">.</span><span class="n">WithTimeout</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">timeOut</span><span class="p">)</span>
    <span class="k">defer</span> <span class="n">cancel</span><span class="p">()</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">c</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="n">p</span><span class="o">.</span><span class="n">pools</span><span class="o">:</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">tCtx</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="o">:</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">tCtx</span><span class="o">.</span><span class="n">Error</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> 
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ClientPool</span><span class="p">)</span><span class="n">RecyleClient</span><span class="p">(</span><span class="n">c</span> <span class="n">Client</span><span class="p">){</span>
    <span class="k">select</span><span class="p">{</span>
    <span class="k">case</span> <span class="n">p</span><span class="o">.</span><span class="n">pools</span> <span class="o">&lt;-</span> <span class="n">c</span><span class="o">:</span>
    <span class="k">default</span><span class="o">:</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// callers:</span>
<span class="n">c</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">pool</span><span class="o">.</span><span class="n">GetClient</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">Background</span><span class="p">())</span>
<span class="n">c</span><span class="o">.</span><span class="n">Send</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">))</span>
<span class="n">pool</span><span class="o">.</span><span class="n">RecycleClient</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</code></pre></div></div>

<p>资源池化模式是在各种driver sdk中必定出现的一种模式，主要的目的就是尽量复用与远程服务之间的tcp链接，这样做的好处 ：一、减少重复建立链接带来的时间延迟（三次握手、四次挥手）；二、减少服务端维持链接的开销（mysql社区版中每条链接都会起一个服务线程）。
上面的示例属于比较<em>简陋</em>的链接池实现，仅仅实现了复用的功能，不具备弹性扩容、空闲统计、心跳检测的功能。</p>

<h3 id="prototype">Prototype</h3>
<p>原型模式，指定使用原型实例创建的对象类型，并从现有对象的“骨架”创建新对象，从而提高性能并将内存占用量降至最低。简单的来讲就是“复制-粘贴”模式。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG4lJS1cbmNsYXNzIEd1bntcbjw8aW50ZXJmYWNlPj5cbitTaG9vdCgpXG59XG4lJS1cbmNsYXNzIFByb3RvdHlwZXtcbitDbG9uZSgpIEd1blxufVxuPDxpbnRlcmZhY2U-PiBQcm90b3R5cGVcbiUlLVxuY2xhc3MgYWs0N3tcbi1pbnQgYnVsbGV0XG4rU2hvb3QoKVxuK0Nsb25lKCkgR3VuXG59XG4lJS1cbmNsYXNzIGNhbGxlcntcbk9wZXJhdGlvbigpXG59XG4lJS1cbmFrNDcgLi58PiBHdW5cbmFrNDcgLi58PiBQcm90b3R5cGVcbmNhbGxlciAuLj4gUHJvdG90eXBlIiwibWVybWFpZCI6bnVsbH0"></p>

<p>golang 示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Gun</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Shoot</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Prototype</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Clone</span><span class="p">()</span> <span class="n">Gun</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ak47</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">bullet</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">ak47</span><span class="p">)</span><span class="n">Shoot</span><span class="p">(){</span>
    <span class="c">//TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">ak47</span><span class="p">)</span><span class="n">Clone</span><span class="p">()</span><span class="n">Gun</span><span class="p">{</span>
    <span class="n">cp</span> <span class="o">:=</span> <span class="o">*</span><span class="n">a</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">cp</span>
<span class="p">}</span>

<span class="c">// caller</span>
<span class="k">var</span> <span class="n">proto</span> <span class="n">Prototype</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ak47</span><span class="p">{</span><span class="n">bullet</span><span class="o">:</span><span class="m">10000</span><span class="p">}</span>
<span class="n">gun</span> <span class="o">:=</span> <span class="n">proto</span><span class="o">.</span><span class="n">Clone</span><span class="p">()</span>
</code></pre></div></div>
<p>这种写法与上面的<code class="language-plaintext highlighter-rouge">builder</code>示例很相似，实际上也确实有一个偷懒的做法，即将对象本身作为自己的<code class="language-plaintext highlighter-rouge">builder</code>：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ak47</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">bullet</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">ak47</span><span class="p">)</span><span class="n">Bullet</span><span class="p">(</span><span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">ak47</span><span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">bullet</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">a</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">ak47</span><span class="p">)</span><span class="n">Shoot</span><span class="p">(){</span>
    <span class="c">//TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">ak47</span><span class="p">)</span><span class="n">Clone</span><span class="p">()</span><span class="n">Gun</span><span class="p">{</span>
    <span class="n">cp</span> <span class="o">:=</span> <span class="o">*</span><span class="n">a</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">cp</span>
<span class="p">}</span>

<span class="c">// caller</span>
<span class="n">gun</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ak47</span><span class="p">{}</span><span class="o">.</span><span class="n">Bullet</span><span class="p">(</span><span class="m">10000</span><span class="p">)</span><span class="o">.</span><span class="n">Clone</span><span class="p">()</span>
</code></pre></div></div>
<p>对于这种写法，作者并不持推荐态度。虽然它节省了工作量，但是会对使用方造成很大的麻烦，使用方要时刻谨小慎微，以保证对象不会被重用，而且一旦出现问题很难排查。</p>

<p>同时作者认为设计模式是灵活多变的，有时一种设计模式可以成为另一种模式的实现，比如抽象工厂模式就可以通过原型模式来实现，而原型模式又可以通过单例模式来实现。</p>

<h3 id="resource-acquisition-is-initialization">Resource acquisition is initialization</h3>

<h3 id="singleton">Singleton</h3>
<p>单例模式，确保一个类只有一个对象，提供一个全局的变量去访问它。
这种模式在<code class="language-plaintext highlighter-rouge">golang</code>开发的常驻服务类型的软件工程中几乎都能见到，但这种模式也被称之为反对象模式，原因有以下几点：</p>
<ul>
  <li>无法继承：当添加新功能的时候，无法通过一个新类降级为包含该功能，打破了关联分离；</li>
  <li>无法控制创建：饮用无法感知是新创建的实例，还是已经存在的；</li>
  <li>无法依赖注入：如果通过依赖注入修改属性，所有依赖该实例的对象都会受到影响；</li>
  <li>对TDD(Test-driven development)很不友好[3]：每一个单独的测试case都很难单独依赖一个“干净”的实例；</li>
</ul>

<p>针对以上的问题都有很多对应的编程技巧，在使用单例模式时候以下的用法是一定要避免的：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">type</span> <span class="n">global</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Increment</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">globalImpl</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">globalImpl</span><span class="p">)</span><span class="n">Increment</span><span class="p">(){</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">GlobalInstance</span> <span class="n">global</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">globalImpl</span><span class="p">{}</span>

<span class="c">// call</span>
<span class="n">GlobalInstance</span><span class="o">.</span><span class="n">Increment</span><span class="p">()</span>
</code></pre></div></div>
<p>直接在代码中调用全局实例，首先，导致代码紧耦合；其次，如果不小心篡改了<code class="language-plaintext highlighter-rouge">GlobalInstance</code> 指向的内存地址，将是灾难性的。
常用的方法是这样的：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">globalInstance</span> <span class="n">global</span>

<span class="k">func</span> <span class="n">GetGlobalIns</span><span class="p">()</span> <span class="n">global</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">globalInstance</span>
<span class="p">}</span>

<span class="c">// call</span>
<span class="n">GetGlobalIns</span><span class="p">()</span><span class="o">.</span><span class="n">Increment</span><span class="p">()</span>
</code></pre></div></div>
<p>通过一层函数的包装，把全局变量<em>保护</em>起来，既可以防止<strong>篡改</strong>的发生，还可以达到<strong>延迟初始化</strong>的效果：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">var</span> <span class="p">(</span>
    <span class="n">globalInstance</span> <span class="n">global</span> 
    <span class="n">once</span> <span class="n">sync</span><span class="o">.</span><span class="n">Once</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">GetGlobalIns</span><span class="p">()</span> <span class="n">global</span> <span class="p">{</span>
    <span class="n">once</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="k">func</span><span class="p">(){</span>
        <span class="k">if</span> <span class="n">globaleInstance</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="n">globalInstance</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">globalImpl</span><span class="p">{}</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="n">globalInstance</span>
<span class="p">}</span>
</code></pre></div></div>
<p>使用 <code class="language-plaintext highlighter-rouge">sync.Once</code>既可以避免引用未初始化变量的悲剧，也可以避免重复初始化的问题。
单例模式对于测试case的不友好可以通过以下的小技巧解决：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">MockGlobalInject</span><span class="p">(</span><span class="n">mockIns</span> <span class="n">global</span><span class="p">){</span>
    <span class="n">globalInstance</span> <span class="o">=</span> <span class="n">mockIns</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">MockGlobalInject</span><span class="p">(</span><span class="n">mockIns</span><span class="p">)</span>
<span class="c">// TODO</span>
</code></pre></div></div>

<h2 id="structural-patterns">Structural patterns</h2>

<h3 id="adapter-wrapper-or-translator">Adapter, Wrapper, or Translator</h3>
<p>适配器模式，主要作用是让一个接口或类型可以支持另一个不适配的接口的功能。
主要的适配模式有两种：</p>
<ul>
  <li>对象适配
<img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG4lJS1cbmNsYXNzIFRhZ2VydHtcbjw8aW50ZXJmYWNlPj5cbitPcGVyYXRpb24oKVxufVxuJSUtXG5jbGFzcyBBZGFwdGVyIHtcbi1BZGFwdGVlIGFwZGF0ZWVcbitPcGVyYXRpb24oKVxufVxuJSUtXG5jbGFzcyBBZGFwdGVlIHtcblNwZWNpYWxPcGVyYXRpb24oKVxufVxuJSUtXG5BZGFwdGVyIC4ufD4gVGFnZXJ0XG5BZGFwdGVyIC0tPiBBZGFwdGVlIiwibWVybWFpZCI6bnVsbH0">
</li>
</ul>

<p>golang 示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Target</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Operation</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Adaptee</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Adaptee</span><span class="p">)</span><span class="n">SpecialOperation</span><span class="p">(){</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Adapter</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">at</span> <span class="o">*</span><span class="n">Adaptee</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span> <span class="n">Adapter</span><span class="p">)</span><span class="n">Operation</span><span class="p">(){</span>
    <span class="n">a</span><span class="o">.</span><span class="n">at</span><span class="o">.</span><span class="n">SpecialOperation</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Adaptee2Target</span><span class="p">(</span><span class="n">at</span> <span class="o">*</span><span class="n">Adaptee</span><span class="p">)</span> <span class="n">Target</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Adapter</span><span class="p">{</span><span class="n">at</span><span class="o">:</span> <span class="n">at</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>类型适配
<img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG4lJS1cbmNsYXNzIFRhZ2VydHtcbjw8aW50ZXJmYWNlPj5cbitPcGVyYXRpb24oKVxufVxuJSUtXG5jbGFzcyBBZGFwdGVyIHtcbi1BZGFwdGVlIGFwZGF0ZWVcbitPcGVyYXRpb24oKVxufVxuJSUtXG5jbGFzcyBBZGFwdGVlIHtcblNwZWNpYWxPcGVyYXRpb24oKVxufVxuJSUtXG5BZGFwdGVyIC4ufD4gVGFnZXJ0XG5BZGFwdGVyIC0tfD4gQWRhcHRlZSIsIm1lcm1haWQiOm51bGx9">
</li>
</ul>

<p>golang 示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Target</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Operation</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Adaptee</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Adaptee</span><span class="p">)</span><span class="n">SpecialOperation</span><span class="p">(){</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Adapter</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Adaptee</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span> <span class="n">Adapter</span><span class="p">)</span><span class="n">Operation</span><span class="p">(){</span>
    <span class="n">a</span><span class="o">.</span><span class="n">SpecialOperation</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Adaptee2Target</span><span class="p">()</span> <span class="n">Target</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Adapter</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>通过附加一层包装，来避免重复性的代码开发，这是非常常用的一种手段，但是也容易造成“层层包装”的现象，尤其是在使用子类多态的情况下。在<code class="language-plaintext highlighter-rouge">C/C++</code>中使用虚成员函数实现多态，在编译阶段无法确定确切调用的函数（静态联编），只有在运行时才能确认（动态联编），而这会增加调用的耗时。</p>

<h3 id="bridge">Bridge</h3>
<p>桥模式：将抽象与其实现分离，从而允许两者独立变化。使用桥模式可是使得抽象和实现在运行时进行绑定选择。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBBYnN0cmFjdGlvbntcbi1JbXBsZW1lbnRvciBpbXBsXG4rZnVuY3Rpb24oKVxufVxuJSUtXG5jbGFzcyBJbXBsZW1lbnRvciB7XG4rb3BlcmF0aW9uSW1wKClcbn1cbiUlLVxuY2xhc3MgSW1wbGVtZW50b3Ixe1xuK29wZXJhdGlvbkltcCgpXG59XG4lJS1cbmNsYXNzIEltcGxlbWVudG9yMntcbitvcGVyYXRpb25JbXAoKVxufVxuJSUtXG5jbGFzcyBBYnN0cmFjdGlvbjF7XG4rZnVuY3Rpb24oKVxufVxuJSUtXG5BYnN0cmFjdGlvbjEgLS18PiBBYnN0cmFjdGlvblxuSW1wbGVtZW50b3IxIC4ufD4gSW1wbGVtZW50b3JcbkltcGxlbWVudG9yMiAuLnw-IEltcGxlbWVudG9yXG5BYnN0cmFjdGlvbiBcIjAuLjFcIiBvLS0gXCIxXCIgSW1wbGVtZW50b3IiLCJtZXJtYWlkIjpudWxsfQ"></p>

<p>golang 示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Abstraction</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Print</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Implementor</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">OperationPrint</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Implementor1</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">i1</span> <span class="o">*</span><span class="n">Implementor1</span><span class="p">)</span><span class="n">OperationPrint</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Implementor2</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">i2</span> <span class="o">*</span><span class="n">Implementor2</span><span class="p">)</span><span class="n">OperationPrint</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%x"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Abstraction1</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">impl</span> <span class="n">Implementor</span>
    <span class="n">x</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a1</span> <span class="o">*</span><span class="n">Abstraction1</span><span class="p">)</span><span class="n">Print</span><span class="p">(){</span>
    <span class="n">a1</span><span class="o">.</span><span class="n">impl</span><span class="o">.</span><span class="n">OperationPrint</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">CreateAbstract</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">,</span> <span class="n">impl</span> <span class="n">Implementor</span><span class="p">)</span> <span class="n">Abstraction</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Abstraction1</span><span class="p">{</span>
        <span class="n">x</span><span class="o">:</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">impl</span><span class="o">:</span> <span class="n">impl</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">CreateAbstract</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Implementor2</span><span class="p">{})</span><span class="o">.</span><span class="n">Print</span><span class="p">()</span>
<span class="n">CreateAbstract</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Implementor1</span><span class="p">{})</span><span class="o">.</span><span class="n">Print</span><span class="p">()</span>
</code></pre></div></div>
<p>由于 golang 不具备继承的语法特性，上面的示例看起来与<code class="language-plaintext highlighter-rouge">Adapter</code>模式有些类似，不过两者的侧重点不一样：<code class="language-plaintext highlighter-rouge">Adapter</code>侧重于不同接口之间的兼容，<code class="language-plaintext highlighter-rouge">Bridge</code>侧重于抽象和实现的分离。</p>

<p>golang 具有第一公民函数的特性，可以将上面的示例进行简化：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Abstraction</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Print</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Abstraction1</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">impl</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="n">x</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a1</span> <span class="o">*</span><span class="n">Abstraction1</span><span class="p">)</span><span class="n">Print</span><span class="p">(){</span>
    <span class="n">a1</span><span class="o">.</span><span class="n">impl</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">CreateAbstract</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">,</span> <span class="n">impl</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="n">Abstraction</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Abstraction1</span><span class="p">{</span>
        <span class="n">x</span><span class="o">:</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">impl</span><span class="o">:</span> <span class="n">impl</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">CreateAbstract</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">){</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">x</span><span class="p">)})</span><span class="o">.</span><span class="n">Print</span><span class="p">()</span>
<span class="n">CreateAbstract</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">){</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%x"</span><span class="p">,</span> <span class="n">x</span><span class="p">)})</span><span class="o">.</span><span class="n">Print</span><span class="p">()</span>
</code></pre></div></div>
<p>这是种比较偏<code class="language-plaintext highlighter-rouge">C/C++</code>的写法，虽然一定程度上破坏了抽象性，但是可以减少代码数量。</p>

<h3 id="composite">Composite</h3>

<p>组合模式，将多个对象以树结构组合，形成部分-整体的层次结构。组合模式可以使客户统一对待单个对象和对象集。</p>

<p><strong>使用场景</strong>：调用方忽略部分和整体的细节，抽象出整体和部分操作的共性部分提供给调用方。</p>

<p>有两种组合模式：</p>
<ul>
  <li>
    <p>集合模式（Design for uniformly）
<img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBDb21wb25lbnR7XG4rIG9wZXJhdGlvbigpXG4rIGFkZChjaGlsZClcbisgcmVtb3ZlKGNoaWxkKVxuKyBnZXRDaGlsZCgpXG59XG4lJS1cbmNsYXNzIExlYWZ7XG4rIG9wZXJhdGlvbigpXG59XG4lJS1cbmNsYXNzIENvbXBvc2l0ZXtcbisgb3BlcmF0aW9uKClcbisgYWRkKGNoaWxkKVxuKyByZW1vdmUoY2hpbGQpXG4rIGdldENoaWxkKClcbn1cbiUlLVxuQ29tcG9uZW50IFwiMS4uKlwiIC0tbyBcIjAuLjFcIiBDb21wb3NpdGVcbkxlYWYgLS18PiBDb21wb25lbnRcbkNvbXBvc2l0ZSAtLXw-IENvbXBvbmVudFxuJSUtIiwibWVybWFpZCI6bnVsbH0"></p>
  </li>
  <li>
    <p>类型安全模式(Design for Type Safety)</p>
  </li>
</ul>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBDb21wb25lbnR7XG4rIG9wZXJhdGlvbigpXG59XG4lJS1cbmNsYXNzIExlYWZ7XG4rIG9wZXJhdGlvbigpXG59XG4lJS1cbmNsYXNzIENvbXBvc2l0ZXtcbisgb3BlcmF0aW9uKClcbisgYWRkKGNoaWxkKVxuKyByZW1vdmUoY2hpbGQpXG4rIGdldENoaWxkKClcbn1cbiUlLVxuTGVhZiAtLXw-IENvbXBvbmVudFxuQ29tcG9zaXRlIC0tfD4gQ29tcG9uZW50XG5Db21wb25lbnQgXCIxLi4qXCIgLS1vIFwiMC4uMVwiIENvbXBvc2l0ZSIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang 示例代码如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">type</span> <span class="n">Component</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Print</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Leaf</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Leaf</span><span class="p">)</span><span class="n">Print</span><span class="p">(){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewLeaf</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">Leaf</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Leaf</span><span class="p">{</span><span class="n">name</span><span class="o">:</span> <span class="n">name</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Composite</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">childs</span> <span class="p">[]</span><span class="n">Component</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Composite</span><span class="p">)</span><span class="n">Add</span><span class="p">(</span><span class="n">ch</span> <span class="n">Component</span><span class="p">){</span>
    <span class="n">c</span><span class="o">.</span><span class="n">childs</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">childs</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Composite</span><span class="p">)</span><span class="n">Remove</span><span class="p">(</span><span class="n">ch</span> <span class="n">Component</span><span class="p">){</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">c</span><span class="o">.</span><span class="n">childs</span><span class="p">{</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">ch</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">childs</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="o">:</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="o">:</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Composite</span><span class="p">)</span><span class="n">GetChild</span><span class="p">(</span><span class="n">index</span> <span class="kt">int</span><span class="p">)</span> <span class="n">Component</span><span class="p">{</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">childs</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Composite</span><span class="p">)</span><span class="n">Print</span><span class="p">(){</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">c</span><span class="o">.</span><span class="n">childs</span><span class="p">{</span>
        <span class="n">c</span><span class="o">.</span><span class="n">Print</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">com</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Composite</span><span class="p">{}</span>
<span class="n">com</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">NewLeaf</span><span class="p">(</span><span class="s">"leaf1"</span><span class="p">))</span>
<span class="n">com</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">NewLeaf</span><span class="p">(</span><span class="s">"leaf2"</span><span class="p">))</span>
<span class="n">com</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">NewLeaf</span><span class="p">(</span><span class="s">"leaf3"</span><span class="p">))</span>


<span class="n">com1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Composite</span><span class="p">{}</span>
<span class="n">com1</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">com</span><span class="p">)</span>
<span class="n">com1</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">NewLeaf</span><span class="p">(</span><span class="s">"leaf4"</span><span class="p">))</span>
<span class="n">com1</span><span class="o">.</span><span class="n">Print</span><span class="p">()</span>
<span class="n">com1</span><span class="o">.</span><span class="n">GetChild</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="o">.</span><span class="n">Print</span><span class="p">()</span>

<span class="c">// output:</span>
<span class="c">// leaf1</span>
<span class="c">// leaf2</span>
<span class="c">// leaf3</span>
<span class="c">// leaf4</span>
<span class="c">// leaf4</span>
</code></pre></div></div>

<p>上面的示例通过组合模式形成一个n叉树，调用根结点的<code class="language-plaintext highlighter-rouge">Print</code>方法就可以按照从左到右的顺序打印出所有叶子节点的<code class="language-plaintext highlighter-rouge">name</code>。</p>

<h3 id="decorator">Decorator</h3>
<p>修饰器模式：动态地将附加的责任附加到对象上，以保持相同的接口。 装饰器为子类提供了灵活的替代方案，以扩展功能。
<strong>使用场景</strong>：在原有类成员函数的基础上，扩展功能并且不去修改该类，这样既可以维持存量调用方式不变，也能满足新需求。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBDb21wb25lbnR7XG48PGludGVyZmFjZT4-XG4rb3BlcmF0aW9uKClcbn1cbiUlLVxuY2xhc3MgQ29uY3JldGV7XG4rb3BlcmF0aW9uKClcbn1cbiUlLVxuY2xhc3MgRGVjb3JhdG9ye1xuLWNvbTogQ29tcG9uZW50XG4rb3BlcmF0aW9uKClcbn1cbiUlLVxuY2xhc3MgRGVjb3JhdG9yMSB7XG4tY29tOiBDb21wb25lbnRcbitvcGVyYXRpb24oKVxufVxuJSUtXG5jbGFzcyBEZWNvcmF0b3IyIHtcbi1jb206IENvbXBvbmVudFxuK29wZXJhdGlvbigpXG59XG4lJS1cbkNvbXBvbmVudCAtLSogRGVjb3JhdG9yXG5Db25jcmV0ZSAuLnw-IENvbXBvbmVudFxuRGVjb3JhdG9yIC4ufD4gQ29tcG9uZW50XG5EZWNvcmF0b3IxIC0tfD4gRGVjb3JhdG9yXG5EZWNvcmF0b3IyIC0tfD4gRGVjb3JhdG9yIiwibWVybWFpZCI6bnVsbH0"></p>

<p>golang 示例代码如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Component</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Print</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Concrete</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">Concrete</span><span class="p">)</span><span class="n">Print</span><span class="p">(){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"concreate"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Decorator</span> <span class="k">struct</span><span class="p">{</span>
   <span class="n">com</span> <span class="n">Component</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">Decorator</span><span class="p">)</span><span class="n">Print</span><span class="p">(){</span>
    <span class="n">d</span><span class="o">.</span><span class="n">com</span><span class="o">.</span><span class="n">Print</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"decorator"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewDecorator</span><span class="p">(</span><span class="n">com</span> <span class="n">Component</span><span class="p">)</span><span class="n">Decorator</span><span class="p">{</span>

<span class="p">}</span>

<span class="c">// callers</span>
<span class="k">var</span> <span class="n">com</span> <span class="n">Component</span> <span class="o">=</span> <span class="n">NewDecorator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Concrete</span><span class="p">{})</span>
<span class="n">com</span><span class="o">.</span><span class="n">Print</span><span class="p">()</span>
<span class="n">com</span> <span class="o">=</span> <span class="n">NewDecorator</span><span class="p">(</span><span class="n">com</span><span class="p">)</span>
<span class="n">com</span><span class="o">.</span><span class="n">Print</span><span class="p">()</span>

<span class="c">// output:</span>
<span class="c">// concreate</span>
<span class="c">// decorator</span>
<span class="c">// concreate</span>
<span class="c">// decorator</span>
<span class="c">// decorator</span>
</code></pre></div></div>
<p>以上的示例代码省去了继承的中间步骤，还可以像<code class="language-plaintext highlighter-rouge">Bridge</code>模式一样，利用<code class="language-plaintext highlighter-rouge">第一公民函数</code>和<code class="language-plaintext highlighter-rouge">闭包</code>特性继续简化如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Decorator</span><span class="p">(</span><span class="nb">print</span> <span class="k">func</span><span class="p">())</span><span class="k">func</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">func</span><span class="p">(){</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"decorator"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">Decorator</span><span class="p">(</span><span class="k">func</span><span class="p">(){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"concreate"</span><span class="p">)</span>
<span class="p">})()</span>
<span class="c">// output:</span>
<span class="c">// concreate</span>
<span class="c">// decorator</span>
</code></pre></div></div>

<h3 id="extension-object">Extension object</h3>

<h3 id="facade">Facade</h3>
<p>门面模式（外观模式）：把一组复杂的接口整合起来，形成几个简单的接口提供给调用方。使得调用放对子系统的依赖最小化、简单化。</p>

<p><strong>使用场景</strong>：子系统的多个接口可以组成一个资源类供调用方使用。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBGYWNhZGV7XG4rb3BlcmF0aW9uKClcbn1cbiUlLVxuY2xhc3MgQ29tcG9uZW50MXtcbitzcGVjaWFsT3BlcmF0aW9uMSgpXG59XG4lJS1cbmNsYXNzIENvbXBvbmVudDJ7XG4rc3BlY2lhbE9wZXJhdGlvbjIoKVxufVxuJSUtXG5jbGFzcyBDb21wb25lbnQze1xuK3NwZWNpYWxPcGVyYXRpb24zKClcbn1cbiUlLVxuRmFjYWRlIC0tPiBDb21wb25lbnQxXG5GYWNhZGUgLS0-IENvbXBvbmVudDJcbkZhY2FkZSAtLT4gQ29tcG9uZW50M1xuJSUtIiwibWVybWFpZCI6bnVsbH0"></p>

<p>golang的示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">CPU</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">CPU</span><span class="p">)</span><span class="n">Freezy</span><span class="p">(){</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">CPU</span><span class="p">)</span><span class="n">Jump</span><span class="p">(</span><span class="n">position</span> <span class="kt">uint64</span><span class="p">){</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">CPU</span><span class="p">)</span><span class="n">Execute</span><span class="p">(){</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">HardDrive</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span><span class="p">(</span><span class="n">hd</span> <span class="o">*</span><span class="n">HardDrive</span><span class="p">)</span><span class="n">Read</span><span class="p">(</span><span class="n">lba</span> <span class="kt">uint64</span><span class="p">,</span> <span class="n">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Memory</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">Memory</span><span class="p">)</span><span class="n">Load</span><span class="p">(</span><span class="n">position</span> <span class="kt">uint64</span><span class="p">,</span> <span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">){</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ComputerFacade</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">hd</span>  <span class="n">HardDrive</span>
    <span class="n">mem</span> <span class="n">Memory</span>
    <span class="n">cpu</span> <span class="n">Cpu</span>

    <span class="n">kBootAddress</span> <span class="kt">uint64</span>
    <span class="n">kBootSector</span> <span class="kt">uint64</span>
    <span class="n">kSectorSize</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">cf</span> <span class="o">*</span><span class="n">ComputerFacade</span><span class="p">)</span><span class="n">Start</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cf</span><span class="o">.</span><span class="n">cpu</span><span class="o">.</span><span class="n">Freezy</span><span class="p">()</span>
    <span class="n">cf</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">kBootAddress</span><span class="p">,</span> <span class="n">cf</span><span class="o">.</span><span class="n">hd</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">kBootSector</span><span class="p">,</span> <span class="n">cf</span><span class="o">.</span><span class="n">kSectorSize</span><span class="p">))</span>
    <span class="n">cf</span><span class="o">.</span><span class="n">cpu</span><span class="o">.</span><span class="n">Jump</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">kBootAddress</span><span class="p">)</span>
    <span class="n">cf</span><span class="o">.</span><span class="n">cpu</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// caller</span>
<span class="n">cf</span> <span class="o">:=</span> <span class="n">ComputerFacade</span><span class="p">{}</span>
<span class="n">cf</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span>
</code></pre></div></div>
<p>在上面的示例中模拟了电脑启动的过程，可以敏锐的发现<code class="language-plaintext highlighter-rouge">cpu</code>、<code class="language-plaintext highlighter-rouge">memory</code>、<code class="language-plaintext highlighter-rouge">hard drive</code> 都是电脑的有机组成部分，它们可以组成一个<code class="language-plaintext highlighter-rouge">computer</code>资源类供调用方使用。</p>

<h3 id="flyweight">Flyweight</h3>
<p>享元模式：多个调用方之间尽量共享依赖单元，从而减少内存的开销。
<strong>使用场景</strong>：在各类算法引擎中或着算法库（openssl）中非常常见，将可变的输入输出与不变的运算逻辑和参数抽离。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBGbHl3ZWlnaHR7XG48PGludGVyZmFjZT4-XG4rb3BlcmF0aW9uKGV4dGluc2ljU3RhdGUpXG59XG4lJS1cbmNsYXNzIEZseXdlaWdodDF7XG5pbnRyaW5zaWNTdGF0ZVxuK29wZXJhdGlvbihleHRpbnNpY1N0YXRlKVxufVxuJSUtXG5jbGFzcyBVbnNoYXJlZEZseXdlaWdodDF7XG5vcGVyYXRpb24oZXh0aW5zaWNTdGF0ZSlcbn1cbiUlLVxuY2xhc3MgRmx5d2VpZ2h0RmFjdG9yeXtcbmdldEZseXdlaWdodChrZXkpRmx5d2VpZ2h0XG59XG4lJS1cbkZseXdlaWdodEZhY3RvcnkgLi4-IEZseXdlaWdodDEgOiBjcmVhdGUgYW5kIHNoYXJlXG5GbHl3ZWlnaHQxIC4ufD4gIEZseXdlaWdodFxuVW5zaGFyZWRGbHl3ZWlnaHQxIC4ufD4gIEZseXdlaWdodCIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang的示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Color</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">red</span> <span class="kt">int</span>
    <span class="n">blue</span> <span class="kt">int</span>
    <span class="n">yellow</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Color</span><span class="p">)</span><span class="n">Set</span><span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">yellow</span> <span class="kt">int</span><span class="p">){</span>
    <span class="n">c</span><span class="o">.</span><span class="n">red</span> <span class="o">=</span> <span class="n">red</span>
    <span class="n">c</span><span class="o">.</span><span class="n">blue</span> <span class="o">=</span> <span class="n">blue</span>
    <span class="n">c</span><span class="o">.</span><span class="n">yellow</span> <span class="o">=</span> <span class="n">yellow</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ColorPalette</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">colors</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">Color</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">cp</span> <span class="o">*</span><span class="n">ColorPalette</span><span class="p">)</span><span class="n">findByName</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">Color</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">cp</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">c</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">cp</span> <span class="o">*</span><span class="n">ColorPalette</span><span class="p">)</span><span class="n">addColor</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span><span class="n">Color</span><span class="p">){</span>
    <span class="n">cp</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">c</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">cp</span> <span class="o">*</span><span class="n">ColorPalatte</span><span class="p">)</span><span class="n">Palatte</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span><span class="o">*</span><span class="n">Color</span><span class="p">{</span>
    <span class="n">c</span> <span class="o">:=</span> <span class="n">cp</span><span class="o">.</span><span class="n">findByName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="no">nil</span><span class="p">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Color</span><span class="p">{}</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">addColor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">c</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewColorPalette</span><span class="p">()</span><span class="o">*</span><span class="n">ColorPalette</span><span class="p">{</span>
    <span class="n">cp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ColorPalette</span><span class="p">{</span>
        <span class="n">colors</span><span class="o">:</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">Color</span><span class="p">{}</span>
    <span class="p">}</span>

    <span class="n">cp</span><span class="o">.</span><span class="n">addColor</span><span class="p">(</span><span class="s">"red"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Color</span><span class="p">{</span><span class="n">red</span><span class="o">:</span><span class="m">255</span><span class="p">})</span>
    <span class="n">cp</span><span class="o">.</span><span class="n">addColor</span><span class="p">(</span><span class="s">"yellow"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Color</span><span class="p">{</span><span class="n">yellow</span><span class="o">:</span><span class="m">255</span><span class="p">})</span>
    <span class="n">cp</span><span class="o">.</span><span class="n">addColor</span><span class="p">(</span><span class="s">"blue"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Color</span><span class="p">{</span><span class="n">blue</span><span class="o">:</span><span class="m">255</span><span class="p">})</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Brush</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">color</span> <span class="o">*</span><span class="n">Color</span>
    <span class="n">palette</span> <span class="o">*</span><span class="n">ColorPalette</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">Brush</span><span class="p">)</span><span class="n">Color</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">palette</span><span class="o">.</span><span class="n">findByName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span> <span class="n">Brush</span><span class="p">)</span> <span class="n">Draw</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="kt">int</span><span class="p">){</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewBrush</span><span class="p">(</span><span class="n">cp</span> <span class="o">*</span><span class="n">ColorPalette</span><span class="p">)</span> <span class="o">*</span><span class="n">Brush</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Brush</span><span class="p">{</span>
        <span class="n">palette</span><span class="o">:</span> <span class="n">cp</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">palette</span> <span class="o">:=</span> <span class="n">NewColorPalette</span><span class="p">()</span>
<span class="n">brush</span> <span class="o">:=</span> <span class="n">NewBrush</span><span class="p">(</span><span class="n">palette</span><span class="p">)</span>
<span class="n">palette</span><span class="o">.</span><span class="n">Palatte</span><span class="p">(</span><span class="s">"green"</span><span class="p">)</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">255</span><span class="p">,</span> <span class="m">255</span><span class="p">)</span>
<span class="n">brush</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s">"green"</span><span class="p">)</span>
<span class="n">brush</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="m">100</span><span class="p">,</span><span class="m">100</span><span class="p">,</span><span class="m">200</span><span class="p">,</span><span class="m">300</span><span class="p">)</span>
</code></pre></div></div>
<p>上面以调色板为例，展示了享元模式的基本用法，享元模式的一个难点在于：共享单元的生命周期的管理。当调用方决定去释放该单元时，一定要保证该单元没有被其他地方占用。通常采用计数器的方式，被引用时计数加一，结束引用时计数减一，当计数为负时释放该单元。</p>

<p>计数器有两种方式，一种方式是与共享单元绑定，另一种方式是由管理共享单元的对象统计。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Unit</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">factor</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">Unit</span><span class="p">)</span><span class="n">Caculate</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span><span class="kt">int</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factor</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span><span class="n">Unit</span><span class="p">)</span><span class="n">SetFactor</span><span class="p">(</span><span class="n">f</span> <span class="kt">int</span><span class="p">){</span>
    <span class="n">u</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">f</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">counter</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">count</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span><span class="n">decr</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">count</span><span class="o">--</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">count</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span><span class="n">incr</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">count</span><span class="o">++</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">count</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">UnitEx</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Unit</span>
    <span class="n">counter</span>
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">UnitFactory</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">units</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">UnitEx</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">uf</span> <span class="o">*</span><span class="n">UnitFactory</span><span class="p">)</span><span class="n">Release</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span><span class="n">UnitEx</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">decr</span><span class="p">()</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// TODO: release unit</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">uf</span> <span class="o">*</span><span class="n">UnitFactory</span><span class="p">)</span><span class="n">Delete</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">){</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">uf</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">u</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">uf</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">uf</span><span class="o">.</span><span class="n">Release</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">uf</span> <span class="o">*</span><span class="n">UnitFactory</span><span class="p">)</span><span class="n">ADD</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">factor</span> <span class="kt">int</span><span class="p">){</span>
    <span class="n">u</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">UnitEx</span><span class="p">{</span><span class="n">name</span><span class="o">:</span><span class="n">name</span><span class="p">}</span>
    <span class="n">u</span><span class="o">.</span><span class="n">SetFactor</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
    <span class="n">uf</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">uf</span> <span class="o">*</span><span class="n">UnitFactory</span><span class="p">)</span><span class="n">Get</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">UnitEx</span> <span class="p">{</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">uf</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
        <span class="n">u</span><span class="o">.</span><span class="n">incr</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">u</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="c">// init unit</span>
<span class="n">unitFactory</span><span class="o">.</span><span class="n">ADD</span><span class="p">(</span><span class="s">"first"</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>

<span class="c">// use unit</span>
<span class="n">u</span> <span class="o">:=</span> <span class="n">unitFactory</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"first"</span><span class="p">)</span> <span class="c">// count = 1</span>
<span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="no">nil</span><span class="p">{</span>
    <span class="n">u</span><span class="o">.</span><span class="n">Caculate</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="c">// return 100</span>
    <span class="n">unitFactory</span><span class="o">.</span><span class="n">Release</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="c">// count = 0</span>
<span class="p">}</span>

<span class="c">// delete unit</span>
<span class="n">unitFactory</span><span class="o">.</span><span class="n">Delete</span><span class="p">(</span><span class="s">"first"</span><span class="p">)</span> <span class="c">// count = -1, delete unit from sets.</span>
</code></pre></div></div>

<p>上面的示例就是第一种方案，把计数器与共享单元绑定。任何调用方用<code class="language-plaintext highlighter-rouge">Get()</code>获取到共享单元后，都不会因为<code class="language-plaintext highlighter-rouge">Delete()</code>导致资源不可用，只要保证对应的<code class="language-plaintext highlighter-rouge">Release()</code>会被调用，也不会出现资源泄漏的问题。</p>

<p>实际上面的示例并不需要计数器，因为<code class="language-plaintext highlighter-rouge">golang</code>中有<code class="language-plaintext highlighter-rouge">gc</code>机制，当<code class="language-plaintext highlighter-rouge">UnitEx</code>对象没有被引用的时候会自动被回收掉。主要是预防在<code class="language-plaintext highlighter-rouge">Relese()</code>阶段有主动释资源放动作（如：关闭socket、关闭 channel等）的情况，由于<code class="language-plaintext highlighter-rouge">gc</code>并非实时具有一定延迟，可能会因为资源短时间大量泄漏（如：积累特别多client socket）导致不可用，所以这种资源保护还是有一定必要的。</p>

<h3 id="front-controller">Front controller</h3>

<h3 id="marker">Marker</h3>

<h3 id="module">Module</h3>

<h3 id="proxy">Proxy</h3>
<p>代理模式：为另一个对象提供代理或占位符，以控制对其的访问。
<strong>使用场景</strong>：对某个对象的访问需要是可控制的，在访问时要执行一些附加的动作。
<img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG4lJS1cbmNsYXNzIFN1YmplY3R7XG48PGludGVyZmFjZT4-XG4rb3BlcmF0aW9uKClcbn1cbiUlLVxuY2xhc3MgUHJveHl7XG4rb3BlcmF0aW9uKClcbn1cbiUlLVxuY2xhc3MgUmVhbFN1YmplY3R7XG4rb3BlcmF0aW9uKClcbn1cbiUlLVxuUHJveHkgLi58PiBTdWJqZWN0XG5SZWFsU3ViamVjdCAuLnw-IFN1YmplY3RcblByb3h5IC0tPiBSZWFsU3ViamVjdCIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang示例代码如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ICar</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">DriveCar</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Car</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span> <span class="o">*</span><span class="n">Car</span><span class="p">)</span><span class="n">DriveCar</span><span class="p">(){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"running ....!!!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ProxyCar</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">driverAge</span> <span class="kt">int</span>
    <span class="n">realCar</span> <span class="n">Car</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ProxyCar</span><span class="p">)</span><span class="n">DriveCar</span><span class="p">(){</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">driverAge</span> <span class="o">&lt;</span> <span class="m">16</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Sorry, the driver is too young to drive."</span><span class="p">)</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="n">p</span><span class="o">.</span><span class="n">realCar</span><span class="o">.</span><span class="n">DriveCar</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>以上示例与<code class="language-plaintext highlighter-rouge">Decorator</code>模式相似，不过两者的侧重点不同，<code class="language-plaintext highlighter-rouge">Proxy</code>模式侧重于访问控制，而<code class="language-plaintext highlighter-rouge">Decorator</code>测重于功能的拓展。</p>

<h3 id="twin">Twin</h3>

<h2 id="behavioural-patterns">Behavioural patterns</h2>

<h3 id="blackboard">Blackboard</h3>

<h3 id="chain-of-responsibility">Chain-of-responsibility</h3>
<p>链式应答模式：通过给一个以上的对象一个处理请求的机会，避免将请求的发送者耦合到其接收者。 链接接收对象，并沿着链传递请求，直到对象处理该请求为止。</p>

<p><strong>使用场景</strong>：一个request需要对应多个应答方，且各个应答方的判断条件不一致。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG4lJS1cbmNsYXNzIEhhbmRsZXJ7XG48PGludGVyZmFjZT4-XG4raGFuZGxlUmVxdWVzdCgpXG59XG4lJS1cbmNsYXNzIFJlY2l2ZXIxe1xuK2hhbmRsZXJSZXF1ZXN0KClcbn1cbiUlLVxuY2xhc3MgUmVjaXZlcjJ7XG4raGFuZGxlclJlcXVlc3QoKVxufVxuJSUtXG5jbGFzcyBSZWNpdmVyM3tcbitoYW5kbGVyUmVxdWVzdCgpXG59XG4lJS1cblJlY2l2ZXIxIC4ufD4gSGFuZGxlclxuUmVjaXZlcjIgLi58PiBIYW5kbGVyXG5SZWNpdmVyMyAuLnw-IEhhbmRsZXJcbkhhbmRsZXIgLS0-IEhhbmRsZXIgOiBzdWNjZXNzb3IiLCJtZXJtYWlkIjpudWxsfQ"></p>

<p>golang 示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">type</span> <span class="n">DebugLevel</span> <span class="kt">int</span>
<span class="k">const</span> <span class="p">(</span>
    <span class="nb">panic</span> <span class="n">DebugLevel</span> <span class="o">=</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="n">itoa</span>
    <span class="kt">error</span>
    <span class="n">warning</span>
    <span class="n">info</span> 
    <span class="n">debug</span> 
    <span class="n">function_error</span>
    <span class="n">function_msg</span>
    <span class="n">all</span> <span class="o">=</span> <span class="m">1023</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Logger</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">DebugLevel</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ConsoleLogger</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">next</span> <span class="n">Logger</span>
    <span class="n">mask</span> <span class="n">DebugLevel</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">cl</span> <span class="o">*</span><span class="n">ConsoleLogger</span><span class="p">)</span><span class="n">Write</span><span class="p">(</span><span class="n">level</span> <span class="n">DebugLevel</span><span class="p">,</span> <span class="n">msg</span> <span class="kt">string</span><span class="p">){</span>
    <span class="k">if</span> <span class="n">cl</span><span class="o">.</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">level</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Console: "</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">cl</span><span class="o">.</span><span class="n">next</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">cl</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewConsoleLogger</span><span class="p">(</span><span class="n">next</span> <span class="n">Logger</span><span class="p">)</span> <span class="n">Logger</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">ConsoleLogger</span><span class="p">{</span>
        <span class="n">next</span><span class="o">:</span> <span class="n">next</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">:</span> <span class="n">all</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">FileLogger</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">next</span> <span class="n">Logger</span>
    <span class="n">mask</span> <span class="n">DebugLevel</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">fl</span> <span class="o">*</span><span class="n">FileLogger</span><span class="p">)</span><span class="n">Write</span><span class="p">(</span><span class="n">level</span> <span class="n">DebugLevel</span><span class="p">,</span> <span class="n">msg</span> <span class="kt">string</span><span class="p">){</span>
    <span class="k">if</span> <span class="n">fl</span><span class="o">.</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">level</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"File: "</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">fl</span><span class="o">.</span><span class="n">next</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fl</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewFileLogger</span><span class="p">(</span><span class="n">next</span> <span class="n">Logger</span><span class="p">)</span> <span class="n">Logger</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">FileLogger</span><span class="p">{</span>
        <span class="n">next</span><span class="o">:</span> <span class="n">next</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">:</span> <span class="n">all</span><span class="o">^</span><span class="n">debug</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">EmailLogger</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">next</span> <span class="n">Logger</span>
    <span class="n">mask</span> <span class="n">DebugLevel</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">el</span> <span class="o">*</span><span class="n">EmailLogger</span><span class="p">)</span><span class="n">Write</span><span class="p">(</span><span class="n">level</span> <span class="n">DebugLevel</span><span class="p">,</span> <span class="n">msg</span> <span class="kt">string</span><span class="p">){</span>
    <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">level</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Email: "</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">next</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">el</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewEmailLogger</span><span class="p">(</span><span class="n">next</span> <span class="n">Logger</span><span class="p">)</span> <span class="n">Logger</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">EmailLogger</span><span class="p">{</span>
        <span class="n">next</span><span class="o">:</span> <span class="n">next</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">:</span><span class="n">function_error</span><span class="o">|</span> <span class="n">function_msg</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">logger</span> <span class="o">:=</span> <span class="n">NewEmailLogger</span><span class="p">(</span><span class="no">nil</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">NewFileLogger</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">NewConsoleLogger</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>

<span class="n">logger</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">"debug message"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">"info message"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">function_msg</span><span class="p">,</span> <span class="s">"function message"</span><span class="p">)</span>

<span class="c">// output:</span>
<span class="c">// Console: debug message</span>
<span class="c">// Console: info message</span>
<span class="c">// File: info message</span>
<span class="c">// Console: function message</span>
<span class="c">// File: function message</span>
<span class="c">// Email: function message</span>
</code></pre></div></div>
<p>以上的示例中把多个输出<code class="language-plaintext highlighter-rouge">logger</code>组成一个<code class="language-plaintext highlighter-rouge">loggers chain</code>，可以由调用方自由组合，又避免了发送方和接收方耦合。以上的写法和<code class="language-plaintext highlighter-rouge">Composite</code>模式有些类似，但并非层级关系，而且每个节点都会对<code class="language-plaintext highlighter-rouge">request</code>进行判断和处理，并非单纯的转发。</p>

<h3 id="command">Command</h3>
<p>命令模式：将请求封装为对象，从而可以对具有不同请求的客户端进行参数化，以及对请求进行排队或记录。 它还允许支持不可撤消的操作。</p>

<p><strong>使用场景</strong>：</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBJbnZva2Vye1xuK2ludm9rZSgpXG59XG4lJS1cbmNsYXNzIENvbW1hbmR7XG48PGludGVyYWZjZT4-XG4rZXhlY3V0ZSgpXG59XG4lJS1cbmNsYXNzIENvbW1hbmQxe1xuK2V4ZWN1dGUoKVxufVxuJSUtXG5jbGFzcyBSZWNpdmVye1xuK2FjdGlvbigpXG59XG4lJS1cbkludm9rZXIgLS0-IENvbW1hbmQ6IGNvbW1hbmRcbkNvbW1hbmQxIC4ufD4gQ29tbWFuZFxuQ29tbWFuZDEgLS0-IFJlY2l2ZXIiLCJtZXJtYWlkIjpudWxsfQ"></p>

<p>golang 示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ForceUnit</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Attack</span><span class="p">()</span>
    <span class="n">Defense</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">solider</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">solider</span><span class="p">)</span><span class="n">Attack</span><span class="p">(){</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">solider</span><span class="p">)</span><span class="n">Defense</span><span class="p">(){</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewSolider</span><span class="p">()</span> <span class="o">*</span><span class="n">solider</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">solider</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ICommand</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Execute</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">AttackCommand</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">f</span> <span class="n">ForceUnit</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ac</span> <span class="o">*</span><span class="n">AttackCommand</span><span class="p">)</span><span class="n">Execute</span><span class="p">(){</span>
    <span class="n">ac</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">Attack</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">CreateAttackCommand</span><span class="p">(</span><span class="n">f</span> <span class="n">ForceUnit</span><span class="p">)</span> <span class="o">*</span><span class="n">AttackCommand</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">AttackCommand</span><span class="p">{</span><span class="n">f</span><span class="o">:</span><span class="n">f</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">DefenseCommand</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">f</span> <span class="n">ForceUnit</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">dc</span> <span class="o">*</span><span class="n">DefenseCommand</span><span class="p">)</span><span class="n">Execute</span><span class="p">(){</span>
    <span class="n">dc</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">Defense</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">CreateDefenceCommand</span><span class="p">(</span><span class="n">f</span> <span class="n">ForceUnit</span><span class="p">)</span> <span class="o">*</span><span class="n">DefenseCommand</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">AttackCommand</span><span class="p">{</span><span class="n">f</span><span class="o">:</span><span class="n">f</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Invoker</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">startCmd</span> <span class="n">ICommand</span>
    <span class="n">stopCmd</span> <span class="n">ICommand</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span><span class="n">Invoker</span><span class="p">)</span><span class="n">Start</span><span class="p">(){</span>
    <span class="n">i</span><span class="o">.</span><span class="n">startCmd</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span><span class="n">Invoker</span><span class="p">)</span><span class="n">Stop</span><span class="p">(){</span>
    <span class="n">i</span><span class="o">.</span><span class="n">stopCmd</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewInvoker</span><span class="p">(</span><span class="n">startCmd</span><span class="p">,</span> <span class="n">stopCmd</span> <span class="n">ICommand</span><span class="p">)</span> <span class="o">*</span><span class="n">Invoker</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Invoker</span><span class="p">{</span><span class="n">startCmd</span><span class="o">:</span><span class="n">startCmd</span><span class="p">,</span> <span class="n">stopCmd</span><span class="o">:</span><span class="n">stopCmd</span><span class="p">}</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">s</span> <span class="o">:=</span> <span class="n">NewSolider</span><span class="p">()</span>
<span class="n">invoker</span> <span class="o">:=</span> <span class="n">NewInvoker</span><span class="p">(</span><span class="n">CreateAttackCommand</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="n">CreateDefenceCommand</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="n">invoker</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span> <span class="c">// solider start attacking.</span>
<span class="n">invoker</span><span class="o">.</span><span class="n">Stop</span><span class="p">()</span> <span class="c">// solider start defensing.</span>
</code></pre></div></div>

<p>上面的示例是通过一个<code class="language-plaintext highlighter-rouge">invoker</code>去控制一个<code class="language-plaintext highlighter-rouge">solider</code>去<code class="language-plaintext highlighter-rouge">attack</code>或<code class="language-plaintext highlighter-rouge">defense</code>，多层的嵌套显得有些冗余。关键在于<code class="language-plaintext highlighter-rouge">invoker</code>这一层可以适应任何<code class="language-plaintext highlighter-rouge">start</code>和 <code class="language-plaintext highlighter-rouge">stop</code>二元模式的<code class="language-plaintext highlighter-rouge">command group</code>。开始的不仅仅可以是<code class="language-plaintext highlighter-rouge">attack command</code>也可以是<code class="language-plaintext highlighter-rouge">building command</code>，这样可以制定一系列的组合在一个“游戏回合”内执行。</p>

<h3 id="interpreter">Interpreter</h3>
<p>解释器模式：给定一种语言并定义其语法的表示形式，使用该表示形式来解释该语言中的句子。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG4lJS1cbmNsYXNzIENvbnRleHR7XG5kYXRhXG59XG4lJS1cbmNsYXNzIEV4cHJlc3Npb257XG48PGludGVyZmFjZT4-XG4rIEludGVycHJldChDb250ZXh0KVxufVxuJSUtXG5jbGFzcyBUZXJtaW5hbEV4cHJlc3Npb24ge1xuKyBpbnRlcnByZXQoQ29udGV4dClcbn1cbiUlLVxuY2xhc3MgRXhwcmVzc2lvbjEge1xuKyBpbnRlcnByZXQoQ29udGV4dClcbn1cbiUlLVxuRXhwcmVzc2lvbiAuLj4gQ29udGV4dFxuRXhwcmVzc2lvbjEgLi58PiBFeHByZXNzaW9uXG5UZXJtaW5hbEV4cHJlc3Npb24gLi58PiBFeHByZXNzaW9uXG5FeHByZXNzaW9uIFwiMS4uKlwiIC0tKiBFeHByZXNzaW9uMSIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang 的示例如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h3 id="iterator">Iterator</h3>
<p>遍历器模式：在不了解一个聚合对象的底层实现情况下，顺序遍历其中所有元素。
<strong>使用场景</strong>：遍历数组、Map、链表等。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG4lJS1cbmNsYXNzIEl0ZXJhdG9ye1xuPDxpbnRlcmZhY2U-PlxuK25leHQoKVxuK2hhc05leHQoKVxufVxuJSUtXG5jbGFzcyBBZ2dyZWdhdGUge1xuPDxpbnRlcmZhY2U-PlxuK2NyZWF0ZUl0ZXJhdG9yKCkgSXRlcmF0b3Jcbn1cbiUlLVxuY2xhc3MgQ29uY3JldGVBZ2dyZWdhdGV7XG4rY3JlYXRlSXRlcmF0b3IoKSBJdGVyYXRvclxufVxuJSUtXG5jbGFzcyBDb25jcmV0ZUl0ZXJhdG9ye1xuK25leHQoKVxuK2hhc05leHQoKVxufVxuJSUtXG5Db25jcmV0ZUFnZ3JlZ2F0ZSAuLnw-IEFnZ3JlZ2F0ZVxuQ29uY3JldGVJdGVyYXRvciAuLnw-IEl0ZXJhdG9yXG5Db25jcmV0ZUFnZ3JlZ2F0ZSAuLj4gQ29uY3JldGVJdGVyYXRvcjogY3JlYXRlXG5Db25jcmV0ZUl0ZXJhdG9yICotLSBDb25jcmV0ZUFnZ3JlZ2F0ZSIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang的示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Iterator</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Next</span><span class="p">()</span> <span class="k">interface</span><span class="p">{}</span>
    <span class="n">HasNext</span><span class="p">()</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Repository</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Iterator</span><span class="p">()</span> <span class="n">Iterator</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ConceteRepository</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">elements</span> <span class="p">[]</span><span class="k">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">cr</span> <span class="o">*</span> <span class="n">ConceteRepository</span><span class="p">)</span><span class="n">Iterator</span><span class="p">()</span><span class="n">Iterator</span><span class="p">{</span>
    <span class="n">iter</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ConceteIterator</span><span class="p">{}</span>
    <span class="c">// copy elements</span>
    <span class="n">iter</span><span class="o">.</span><span class="n">cr</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">cr</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">cr</span><span class="o">.</span><span class="n">elements</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span> 

<span class="k">type</span> <span class="n">ConceteIterator</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">index</span> <span class="kt">int</span>
    <span class="n">end</span> <span class="kt">int</span>
    <span class="n">cr</span> <span class="n">ConceteRepository</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ci</span> <span class="o">*</span><span class="n">ConceteIterator</span><span class="p">)</span><span class="n">HasNext</span><span class="p">()</span> <span class="kt">bool</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">end</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ci</span> <span class="o">*</span><span class="n">ConceteIterator</span><span class="p">)</span><span class="n">Next</span><span class="p">()</span><span class="k">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">ci</span><span class="o">.</span><span class="n">HasNext</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="n">ci</span><span class="o">.</span><span class="n">index</span><span class="o">++</span>
        <span class="k">return</span> <span class="n">cr</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">ci</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="k">for</span> <span class="n">iter</span> <span class="o">:=</span> <span class="n">repository</span><span class="o">.</span><span class="n">Iterator</span><span class="p">()</span> <span class="p">;</span> <span class="n">iter</span><span class="o">.</span><span class="n">HasNext</span><span class="p">();</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%#v"</span><span class="p">,</span> <span class="n">iter</span><span class="o">.</span><span class="n">Next</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>以上的示例代码是展示了一个简单的遍历对象内数组元素的过程，在实现过程中有一点需要注意：拷贝 <code class="language-plaintext highlighter-rouge">elements</code> 数组而不是直接的引用，对当时的状态做一个快照。</p>

<p>遍历模式在<code class="language-plaintext highlighter-rouge">C++</code>的 <code class="language-plaintext highlighter-rouge">std</code>库中是十分关键的模式，在<code class="language-plaintext highlighter-rouge">golang</code>中的一些<code class="language-plaintext highlighter-rouge">database driver</code>包中也十分常见，主要用途是遍历查询的结果。</p>

<h3 id="mediator">Mediator</h3>
<p>中介者模式：定义一个对象，该对象封装了一组对象之间的交互方式。中介类通过阻止对象之间显式地相互引用来促进松散耦合，并且它允许它们的交互独立地变化。</p>

<p><strong>使用场景</strong>：两个具体类之间可能发生互相引用的情况，例如：用户要通过邮箱发邮件，邮箱要把邮件投递给每个用户。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBNZWRpYXRvcntcbjw8aW50ZXJmYWNlPj5cbittZWRpYXRlKClcbn1cbiUlLVxuY2xhc3MgQ29sbGVhZ3Vle1xuPDxpbnRlcmZhY2U-PlxuK2dldFN0YXRlKClcbn1cbiUlLVxuY2xhc3MgQ29uY2V0ZU1lZGlhdG9yIHtcbittZWRpYXRlKClcbn1cbiUlLVxuY2xhc3MgQ29uY2V0ZUNvbGxlYWd1ZTEge1xuK2dldFN0YXRlKClcbithY3Rpb24xKClcbn1cbiUlLVxuY2xhc3MgQ29uY2V0ZUNvbGxlYWd1ZTIge1xuK2dldFN0YXRlKClcbithY3Rpb24yKClcbn1cbiUlLVxuTWVkaWF0b3IgPC0tIENvbGxlYWd1ZVxuQ29uY2V0ZU1lZGlhdG9yIC0tPiBDb25jZXRlQ29sbGVhZ3VlMVxuQ29uY2V0ZUNvbGxlYWd1ZTEgLi58PiBDb2xsZWFndWVcbkNvbmNldGVNZWRpYXRvciAtLT4gQ29uY2V0ZUNvbGxlYWd1ZTJcbkNvbmNldGVDb2xsZWFndWUyIC4ufD4gQ29sbGVhZ3VlXG5Db25jZXRlTWVkaWF0b3IgLi58PiBNZWRpYXRvciIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang 示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">type</span> <span class="n">Email</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">From</span> <span class="kt">string</span>
    <span class="n">To</span> <span class="kt">string</span>
    <span class="n">Message</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Mediator</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">SendMessage</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">message</span> <span class="kt">string</span><span class="p">)</span>
    <span class="n">ReceiveMessage</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">message</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">User</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">md</span> <span class="n">Mediator</span>
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewUser</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">md</span> <span class="o">*</span><span class="n">ConceteMediator</span><span class="p">)</span> <span class="o">*</span><span class="n">User</span><span class="p">{</span>
    <span class="n">user</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="p">{</span><span class="n">name</span><span class="o">:</span><span class="n">name</span><span class="p">,</span> <span class="n">md</span><span class="o">:</span><span class="n">md</span><span class="p">}</span>
    <span class="n">md</span><span class="o">.</span><span class="n">addUser</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">user</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span><span class="n">User</span><span class="p">)</span> <span class="n">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">name</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span><span class="n">Receive</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">message</span> <span class="kt">string</span><span class="p">){</span>
    <span class="k">if</span> <span class="n">sender</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="n">name</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"from %s to %s: %s"</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
    <span class="p">}</span> 
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span><span class="n">Send</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">message</span> <span class="kt">string</span><span class="p">){</span>
    <span class="n">u</span><span class="o">.</span><span class="n">md</span><span class="o">.</span><span class="n">SendMessage</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">EMailBox</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">md</span> <span class="n">Mediator</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewEmailBox</span><span class="p">(</span><span class="n">md</span> <span class="o">*</span><span class="n">ConceteMediator</span><span class="p">)</span><span class="o">*</span><span class="n">EMailBox</span><span class="p">{</span>
    <span class="n">eb</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">EMailBox</span><span class="p">{</span>
        <span class="n">md</span> <span class="o">:</span> <span class="n">md</span>
    <span class="p">}</span>

    <span class="n">md</span><span class="o">.</span><span class="n">setEmailBox</span><span class="p">(</span><span class="n">eb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">md</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">eb</span> <span class="o">*</span><span class="n">EMailBox</span><span class="p">)</span><span class="n">push</span><span class="p">(</span><span class="n">email</span> <span class="n">Email</span><span class="p">){</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">eb</span> <span class="o">*</span><span class="n">EMailBox</span><span class="p">)</span><span class="n">pop</span><span class="p">()</span><span class="n">Email</span><span class="p">{</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">eb</span> <span class="o">*</span><span class="n">EMailBox</span><span class="p">)</span><span class="n">number</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">eb</span> <span class="o">*</span><span class="n">EMailBox</span><span class="p">)</span><span class="n">HasFree</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">eb</span> <span class="o">*</span><span class="n">EMailBox</span><span class="p">)</span><span class="n">Delivery</span><span class="p">(){</span>
    <span class="k">for</span> <span class="n">eb</span><span class="o">.</span><span class="n">number</span><span class="p">()</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">email</span> <span class="o">:=</span> <span class="n">eb</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> 
        <span class="n">md</span><span class="o">.</span><span class="n">ReceiveMessage</span><span class="p">(</span><span class="n">email</span><span class="o">.</span><span class="n">from</span><span class="p">,</span> <span class="n">email</span><span class="o">.</span><span class="n">to</span><span class="p">,</span> <span class="n">email</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ConceteMediator</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">emailBox</span> <span class="o">*</span><span class="n">EMailBox</span>
    <span class="n">receivers</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">User</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">ConceteMediator</span><span class="p">)</span><span class="n">setEmailBox</span><span class="p">(</span><span class="n">eb</span> <span class="o">*</span><span class="n">EMailBox</span><span class="p">){</span>
    <span class="n">m</span><span class="o">.</span><span class="n">emailBox</span> <span class="o">=</span> <span class="n">eb</span>
    <span class="n">eb</span><span class="o">.</span><span class="n">md</span> <span class="o">=</span> <span class="n">m</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">ConceteMediator</span><span class="p">)</span><span class="n">addUser</span><span class="p">(</span><span class="n">user</span> <span class="o">*</span><span class="n">User</span><span class="p">){</span>
    <span class="n">m</span><span class="o">.</span><span class="n">receivers</span><span class="p">[</span><span class="n">user</span><span class="o">.</span><span class="n">Name</span><span class="p">()]</span> <span class="o">=</span> <span class="n">user</span>
    <span class="n">user</span><span class="o">.</span><span class="n">md</span> <span class="o">=</span> <span class="n">m</span>
<span class="p">}</span>


<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">ConceteMediator</span><span class="p">)</span><span class="n">SendMessage</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">message</span> <span class="kt">string</span><span class="p">){</span>
   <span class="n">sender</span> <span class="o">:=</span> <span class="n">user</span><span class="o">.</span><span class="n">Name</span><span class="p">()</span>
   <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">emialBox</span><span class="o">.</span><span class="n">HasFree</span><span class="p">()</span> <span class="p">{</span>
       <span class="n">m</span><span class="o">.</span><span class="n">emialBox</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">Email</span><span class="p">{</span><span class="n">From</span><span class="o">:</span> <span class="n">from</span><span class="p">,</span> <span class="n">To</span><span class="o">:</span> <span class="n">to</span><span class="p">,</span> <span class="n">Message</span><span class="o">:</span> <span class="n">message</span><span class="p">})</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">ConceteMediator</span><span class="p">)</span><span class="n">ReceiveMessage</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">message</span> <span class="kt">string</span><span class="p">){</span>
        <span class="n">rc</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">m</span><span class="o">.</span><span class="n">receivers</span><span class="p">[</span><span class="n">to</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
            <span class="n">rc</span><span class="o">.</span><span class="n">Receive</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">emailBox</span> <span class="o">:=</span> <span class="n">NewEmailBox</span><span class="p">(</span><span class="n">mediator</span><span class="p">)</span>
<span class="n">alice</span> <span class="o">:=</span> <span class="n">NewUser</span><span class="p">(</span><span class="s">"alice"</span><span class="p">,</span> <span class="n">mediator</span><span class="p">)</span>
<span class="n">bob</span> <span class="o">:=</span> <span class="n">NewUser</span><span class="p">(</span><span class="s">"bob"</span><span class="p">,</span> <span class="n">mediator</span><span class="p">)</span>

<span class="n">alice</span><span class="o">.</span><span class="n">Send</span><span class="p">(</span><span class="s">"bob"</span><span class="p">,</span> <span class="s">"nice to meet you."</span><span class="p">)</span>
<span class="n">emailBox</span><span class="o">.</span><span class="n">Delivery</span><span class="p">()</span>

<span class="c">// output:</span>
<span class="c">// from alice to bob: nice to meet you.</span>
</code></pre></div></div>
<p>上面的示例展示了邮箱发送邮件的过程，用户把邮件通过<code class="language-plaintext highlighter-rouge">Mediator</code>放到邮箱中，邮箱在通过<code class="language-plaintext highlighter-rouge">Mediator</code> 投递到每个用户。如果不添加<code class="language-plaintext highlighter-rouge">Mediator</code>类，则会出现<code class="language-plaintext highlighter-rouge">User</code> 和<code class="language-plaintext highlighter-rouge">EmailBox</code>互相调用的情况，导致强耦合。</p>

<h3 id="memento">Memento</h3>
<p>备忘录模式：在不打破对象封装的情况下，备份对象的状态，帮助对象回滚到前一状态。
<strong>使用模式</strong>：对于需要版本记录的对象，适用于备忘录模式。例如：执行了一个错误的提交，需要回滚到前一个版本。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBPcmlnaW5hdG9ye1xuLSBzdGF0ZVxuKyBjcmVhdGVNZW1lbnRvKClcbisgcmVzdG9yZU1lbWVudG8obWVtZW50bylcbn1cbiUlLVxuY2xhc3MgTWVtZW50byB7XG4tIHN0YXRlXG4rIGdldFN0YXRlKClcbisgc2V0U3RhdGUoKVxufVxuJSUtXG5PcmlnaW5hdG9yIC4uPiBNZW1lbnRvOiA8PGNyZWF0ZT4-XG5PcmlnaW5hdG9yIC0tPiBNZW1lbnRvIiwibWVybWFpZCI6bnVsbH0"></p>

<p>golang的示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Memento</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">state</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">Memento</span><span class="p">)</span><span class="n">setState</span><span class="p">(</span><span class="n">state</span> <span class="kt">int</span><span class="p">){</span>
    <span class="n">m</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">Memento</span><span class="p">)</span><span class="n">getState</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">state</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">EWallet</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">balance</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewEWallet</span><span class="p">(</span><span class="n">balance</span> <span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">EWallet</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">EWallet</span><span class="p">{</span><span class="n">balance</span><span class="o">:</span> <span class="n">balance</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ew</span> <span class="o">*</span><span class="n">EWallet</span><span class="p">)</span><span class="n">CreateMemento</span><span class="p">()</span> <span class="o">*</span><span class="n">Memento</span><span class="p">{</span>
    <span class="n">m</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Memento</span><span class="p">)</span>
    <span class="n">m</span><span class="o">.</span><span class="n">setState</span><span class="p">(</span><span class="n">ew</span><span class="o">.</span><span class="n">balance</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ew</span> <span class="o">*</span><span class="n">EWallet</span><span class="p">)</span><span class="n">RestoreMemento</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">Memento</span><span class="p">){</span>
    <span class="n">ew</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">getState</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">ew</span> <span class="o">*</span><span class="n">EWallet</span><span class="p">)</span><span class="n">Pay</span><span class="p">(</span><span class="n">pay</span> <span class="kt">int</span><span class="p">){</span>
    <span class="n">ew</span><span class="o">.</span><span class="n">balance</span> <span class="o">-=</span> <span class="n">pay</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">ewallet</span> <span class="o">:=</span> <span class="n">NewEWallet</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
<span class="n">mem</span> <span class="o">:=</span> <span class="n">ewallet</span><span class="o">.</span><span class="n">CreateMemento</span><span class="p">()</span>

<span class="n">ewallet</span><span class="o">.</span><span class="n">Pay</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="c">// 90</span>
<span class="n">ewallet</span><span class="o">.</span><span class="n">RestoreMemento</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="c">// back to 100</span>
</code></pre></div></div>
<p>对于开发人员来讲，每一个函数的调用，都是一次状态的流转。对状态进行备份，当触发回滚时再恢复状态，此时就需要用到<code class="language-plaintext highlighter-rouge">Memento</code>模式。</p>

<h3 id="observer">observer</h3>
<p>观察者模式：定义对象之间的一对多依赖关系，其中一个对象的状态变化导致其所有依赖关系都被通知并自动更新。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBvYnNlcnZlciB7XG48PGludGVyZmFjZT4-XG4rdXBkYXRlKClcbn1cbiUlLVxuY2xhc3Mgc3ViamVjdCB7XG4rYXR0ZWNoKG9ic2VydmVyKVxuK2RldHRlY2gob2JzZXJ2ZXIpXG4rbm90aWZ5KClcbn1cbiUlLVxuY2xhc3MgY29udGV0ZU9ic2VydmVyMXtcbit1cGRhdGUoKVxufVxuJSUtXG5jbGFzcyBjb250ZXRlT2JzZXJ2ZXIye1xuK3VwZGF0ZSgpXG59XG4lJS1cbnN1YmplY3QgLS0-IG9ic2VydmVyIDogb2Jlc2VydmVyc1xuY29udGV0ZU9ic2VydmVyMSAuLnw-IG9ic2VydmVyXG5jb250ZXRlT2JzZXJ2ZXIyIC4ufD4gb2JzZXJ2ZXJcbiUlLSIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang 示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Observer</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Update</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">conteteObserver</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">state</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">co</span> <span class="o">*</span><span class="n">conteteObserver</span><span class="p">)</span><span class="n">Update</span><span class="p">(){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Check if receive pay."</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewObserver</span><span class="p">()</span> <span class="n">Observer</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">conteteObserver</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">subject</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="n">obs</span> <span class="k">map</span><span class="p">[</span><span class="n">observer</span><span class="p">]</span><span class="k">struct</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">subject</span><span class="p">)</span><span class="n">Attech</span><span class="p">(</span><span class="n">o</span> <span class="n">observer</span><span class="p">){</span>
    <span class="n">s</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="k">struct</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">subject</span><span class="p">)</span><span class="n">Dettech</span><span class="p">(</span><span class="n">o</span> <span class="n">observer</span><span class="p">){</span>
    <span class="nb">delete</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">obs</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">subject</span><span class="p">)</span><span class="n">Notify</span><span class="p">(){</span>
    <span class="k">for</span> <span class="n">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span><span class="o">.</span><span class="n">obs</span> <span class="p">{</span>
        <span class="n">o</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Wallet</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">sub</span> <span class="n">subject</span>
    <span class="n">balance</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span><span class="n">Wallet</span><span class="p">)</span><span class="n">Pay</span><span class="p">(</span><span class="n">pay</span> <span class="kt">int</span><span class="p">){</span>
    <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">pay</span> <span class="p">{</span>
        <span class="n">w</span><span class="o">.</span><span class="n">balance</span> <span class="o">-=</span> <span class="n">pay</span>
        <span class="n">w</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">Notify</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span><span class="n">Wallet</span><span class="p">)</span><span class="n">PaySubject</span><span class="p">()</span> <span class="o">*</span><span class="n">subject</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">w</span><span class="o">.</span><span class="n">sub</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">wallet</span><span class="o">.</span><span class="n">PaySubject</span><span class="p">()</span><span class="o">.</span><span class="n">Attech</span><span class="p">(</span><span class="n">NewObserver</span><span class="p">())</span>
<span class="n">wallet</span><span class="o">.</span><span class="n">Pay</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
<span class="c">// output:</span>
<span class="c">// Check if receive pay.</span>
</code></pre></div></div>

<p>上面给出了一个检测转账事件的示例，<code class="language-plaintext highlighter-rouge">Wallet</code>类直接关联到<code class="language-plaintext highlighter-rouge">Subject</code>是有些强耦合性的，可以利用<code class="language-plaintext highlighter-rouge">Mediator</code>模式、<code class="language-plaintext highlighter-rouge">Flywegiht</code>模式或<code class="language-plaintext highlighter-rouge">Singelton</code>模式进行事件转发。
这里需要注意的是，观察者模式是GoF提到的23种模式的一种，只是一个基本概念。并没有解决如下问题：1.消除对观察到变化主题的兴趣；2.在通知观察者之前或之后，对被观察到的主题进行特殊的逻辑处理。</p>

<p>该模式不记录通知发送，也不保证观察者已收到更改。这些问题通常在消息队列系统中处理，观察者模式是消息队列系统中的一小部分。<code class="language-plaintext highlighter-rouge">publish-subscribe</code>是一种消息模式，而不是一种设计模式，两者不要混淆。</p>

<h3 id="state">state</h3>
<p>状态模式：当对象的内部状态更改时，允许其更改其行为。该对象似乎将更改其类。</p>

<p><strong>使用场景</strong>：对象内部包含一个有限状态机时，不同的状态对应不同处理类。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBDb250ZXh0e1xuLXN0YXRlIFN0YXRlXG4rUmVxdWVzdCgpXG59XG4lJS1cbmNsYXNzIFN0YXRle1xuPDxpbnRlcmZhY2U-PlxuK0hhbmRsZSgpXG59XG4lJS1cbmNsYXNzIENvbmNldGVTdGF0ZUF7XG4rSGFuZGxlKClcbn1cbiUlLVxuY2xhc3MgQ29uY2V0ZVN0YXRlQntcbitIYW5kbGUoKVxufVxuJSUtXG5TdGF0ZSAtLSogQ29udGV4dCA6IHN0YXRlLkhhbmRsZSgpXG5TdGF0ZSA8fC4uIENvbmNldGVTdGF0ZUFcblN0YXRlIDx8Li4gQ29uY2V0ZVN0YXRlQlxuJSUtIiwibWVybWFpZCI6bnVsbH0"></p>

<p>golang的示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">State</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Check</span><span class="p">(</span><span class="n">num</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">normalState</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">normalState</span><span class="p">)</span><span class="n">Check</span><span class="p">(</span><span class="n">num</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">wariningState</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">wariningState</span><span class="p">)</span><span class="n">Check</span><span class="p">(</span><span class="n">num</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">panicState</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">panicState</span><span class="p">)</span><span class="n">Check</span><span class="p">(</span><span class="n">num</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">recoverState</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">recoverState</span><span class="p">)</span><span class="n">Check</span><span class="p">(</span><span class="n">num</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Context</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">state</span> <span class="n">State</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Context</span><span class="p">)</span><span class="n">Request</span><span class="p">(</span><span class="n">num</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">c</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">Check</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c">// TODO</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Context</span><span class="p">)</span><span class="n">SwitchState</span><span class="p">(</span><span class="n">state</span> <span class="n">State</span><span class="p">){</span>
    <span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="c">// normal</span>
<span class="n">context</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="m">10086</span><span class="p">)</span>

<span class="c">// warning</span>
<span class="n">context</span><span class="o">.</span><span class="n">SwitchState</span><span class="p">(</span><span class="n">wariningState</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="m">10086</span><span class="p">)</span>

<span class="c">// recover</span>
<span class="n">context</span><span class="o">.</span><span class="n">SwitchState</span><span class="p">(</span><span class="n">recoverState</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="m">10086</span><span class="p">)</span>
</code></pre></div></div>

<p>状态模式可以将状态切换和处理逻辑分割开，在包含多个状态的流程中可以降低代码的复杂度，增加可读性。需要注意的是，状态切换动作尽量不要放在逻辑处理单元中来执行，这样会增加耦合性，也不利于代码维护。</p>

<h3 id="strategy">Strategy</h3>

<p>策略模式：定义一系列算法，封装每个算法，并使它们可互换。 策略使算法可以独立于使用该算法的客户端而变化。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBDb250ZXh0e1xuLXN0cmF0ZWd5IFN0cmF0ZWd5XG4rUmVxdWVzdCgpXG59XG4lJS1cbmNsYXNzIFN0cmF0ZWd5e1xuPDxpbnRlcmZhY2U-PlxuK0V4Y3V0ZSgpXG59XG4lJS1cbmNsYXNzIENvbmNldGVTdHJhdGVneUF7XG4rRXhjdXRlKClcbn1cbiUlLVxuY2xhc3MgQ29uY2V0ZVN0cmF0ZWd5QntcbitFeGN1dGUoKVxufVxuJSUtXG5TdHJhdGVneSAtLSogQ29udGV4dCA6IHN0YXRlLkhhbmRsZSgpXG5TdHJhdGVneSA8fC4uIENvbmNldGVTdHJhdGVneUFcblN0cmF0ZWd5IDx8Li4gQ29uY2V0ZVN0cmF0ZWd5QiIsIm1lcm1haWQiOm51bGx9"></p>

<p>golang的示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Price</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">GetActPrice</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="n">float</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">discountedPrice</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">discountedPrice</span><span class="p">)</span> <span class="n">GetActPrice</span><span class="p">(</span><span class="n">rawPrice</span> <span class="n">float</span><span class="p">,</span> <span class="n">num</span> <span class="kt">int</span><span class="p">)</span> <span class="n">float</span><span class="p">{</span>
    <span class="n">sum</span> <span class="o">:=</span> <span class="n">rawPrice</span> <span class="o">*</span> <span class="n">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">num</span><span class="p">){</span>
        <span class="k">case</span> <span class="m">1</span><span class="o">:</span>
            <span class="n">sum</span> <span class="o">*=</span> <span class="m">0.95</span>
        <span class="k">case</span> <span class="m">2</span><span class="o">:</span>
            <span class="n">sum</span> <span class="o">*=</span> <span class="m">0.85</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">sum</span> <span class="o">*=</span> <span class="m">0.75</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">sum</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">normalPrice</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">normalPrice</span><span class="p">)</span> <span class="n">GetActPrice</span><span class="p">(</span><span class="n">rawPrice</span> <span class="n">float</span><span class="p">,</span> <span class="n">num</span> <span class="kt">int</span><span class="p">)</span> <span class="n">float</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">rawPrice</span><span class="o">*</span><span class="n">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">CustomerBill</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">price</span> <span class="n">Price</span>
    <span class="n">bills</span> <span class="p">[]</span><span class="n">float</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">CustomerBill</span><span class="p">)</span><span class="n">Add</span><span class="p">(</span><span class="n">rawPrice</span> <span class="n">float</span><span class="p">,</span> <span class="n">num</span> <span class="kt">int</span><span class="p">){</span>
    <span class="n">c</span><span class="o">.</span><span class="n">bills</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">bills</span><span class="p">,</span> <span class="n">price</span><span class="o">.</span><span class="n">GetActPrice</span><span class="p">(</span><span class="n">rawPrice</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">CustomerBill</span><span class="p">)</span><span class="n">Set</span><span class="p">(</span><span class="n">price</span> <span class="n">Price</span><span class="p">){</span>
    <span class="n">c</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>
<span class="p">}</span>

<span class="c">// callers</span>

<span class="c">// start discounting</span>
<span class="n">customerBill</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">discountedPrice</span><span class="p">)</span>
<span class="n">customerBill</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span> <span class="c">// 40 * 0.75</span>
<span class="n">customerBill</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">300</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c">// 300 * 0.95</span>
<span class="n">customerBill</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">50</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="c">// 50 *2 * 0.85 </span>

<span class="c">// stop discounting</span>
<span class="n">customerBill</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">normalPrice</span><span class="p">)</span>
<span class="n">customerBill</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">50</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="c">// 50 *2 </span>
</code></pre></div></div>

<p>上面的类图和示例都与<code class="language-plaintext highlighter-rouge">State</code>模式十分相似，但是两者有一个最显著的不同：触发切换时机，<code class="language-plaintext highlighter-rouge">State</code>模式的切换是由处理逻辑触发的（根据其返回结果，或者直接在处理逻辑单元中执行状态切换），而<code class="language-plaintext highlighter-rouge">Strategy</code>的切换与逻辑单元无关。</p>

<h3 id="template">Template</h3>
<p>模板模式：在操作中定义算法的框架，将某些步骤推迟到子类。 模板方法允许子类重新定义算法的某些步骤，而无需更改算法的结构。</p>

<p><strong>使用场景</strong>：在一些上层的逻辑流程框架相同，但底层处理函数有细微差别的情况下。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG4lJS1cbmNsYXNzIEFsZ29yaXRobXtcbisgcHJpbWl0aXZlMSgpXG4rIHByaW1pdGl2ZTIoKVxuKyBwcmltaXRpdmUzKClcbisgcnVuKClcbn1cbiUlLVxuY2xhc3MgQ29udGVjdEFsZ29yaXRobTF7XG4rIHByaW1pdGl2ZTEoKVxuKyBwcmltaXRpdmUyKClcbisgcHJpbWl0aXZlMygpXG4rIHJ1bigpXG59XG4lJS1cbkNvbnRlY3RBbGdvcml0aG0xIC0tfD4gQWxnb3JpdGhtXG5BbGdvcml0aG0gLS0-IEFsZ29yaXRobTogcnVuKCl7IHRoaXMtPnByaW1pdGl2ZTEoKSAuLi4gfSIsIm1lcm1haWQiOm51bGx9"></p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Primitive</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">primitive1</span><span class="p">()</span>
    <span class="n">primitive2</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Template</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Primitive</span>
    <span class="n">Run</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">templateBase</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">p</span> <span class="n">Primitive</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">templateBase</span><span class="p">)</span><span class="n">Run</span><span class="p">(){</span>
    <span class="n">t</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">primitive1</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">primitive2</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">template1</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">templateBase</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">template1</span><span class="p">)</span><span class="n">primitive1</span><span class="p">(){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"primitive1"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">template1</span><span class="p">)</span><span class="n">primitive2</span><span class="p">(){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"primitive2"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewTemplate</span><span class="p">()</span><span class="n">Template</span><span class="p">{</span>
    <span class="n">t1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">template1</span><span class="p">{}</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="k">return</span> <span class="n">t1</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="n">t</span> <span class="o">:=</span> <span class="n">NewTemplate</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span>

<span class="c">// output:</span>
<span class="c">// primitive1</span>
<span class="c">// primitive2</span>
</code></pre></div></div>
<p>上面的示例中模仿了继承基类的过程，由于<code class="language-plaintext highlighter-rouge">golang</code>没有虚函数特性，只能把底层函数抽象为接口<code class="language-plaintext highlighter-rouge">Primitive</code>，在<em>基础模板</em>中调用。在具体实现类中包含<em>基础模板</em>，同时实现<code class="language-plaintext highlighter-rouge">Primitive</code>接口，再将具体实现类的对象赋值给<em>基础模板</em>引用。</p>

<h3 id="vistor">vistor</h3>
<p>访客模式：表示要在对象结构的元素上执行的操作。访客可以定义新操作，而无需更改其所操作元素的类。</p>

<p><strong>使用模式</strong>：这种模式在需要访问多个类型状态，又不想打破被访问对象结构的情况下使用很是方便。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5jbGFzcyBFbGVtZW50e1xuPDxpbnRlcmZhY2U-PlxuK2FjY2VwdCh2aXN0b3IpXG59XG4lJS1cbmNsYXNzIEVsZW1lbnQxIHtcbithY2NlcHQodmlzdG9yKVxufVxuJSUtXG5jbGFzcyBFbGVtZW50MntcbithY2NlcHQodmlzdG9yKVxufVxuJSUtXG5jbGFzcyB2aXN0b3J7XG48PGludGVyZmFjZT4-XG4rdmlzdEVsZW1lbnQxKEVsZW1lbnQxKVxuK3Zpc3RFbGVtZW50MihFbGVtZW50Milcbn1cbiUlLVxuY2xhc3MgY29udGV0ZVZpc3Rvcntcbit2aXN0RWxlbWVudDEoRWxlbWVudDEpXG4rdmlzdEVsZW1lbnQyKEVsZW1lbnQyKVxufVxuJSUtXG5jb250ZXRlVmlzdG9yIC4ufD4gdmlzdG9yXG52aXN0b3IgLi4-ICBFbGVtZW50MlxudmlzdG9yIC4uPiAgRWxlbWVudDFcbkVsZW1lbnQxIC4ufD4gRWxlbWVudFxuRWxlbWVudDIgLi58PiBFbGVtZW50XG5FbGVtZW50IC4uPiB2aXN0b3IiLCJtZXJtYWlkIjpudWxsfQ">
golang 示例代码如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">vistor</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">VistCar</span><span class="p">(</span><span class="o">*</span><span class="n">Car</span><span class="p">)</span>
    <span class="n">VistDriver</span><span class="p">(</span><span class="o">*</span><span class="n">Driver</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">element</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Accept</span><span class="p">(</span><span class="n">vistor</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Car</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Car</span><span class="p">)</span><span class="n">Accept</span><span class="p">(</span><span class="n">vistor</span><span class="p">){</span>
    <span class="n">vistor</span><span class="o">.</span><span class="n">VistCar</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Driver</span> <span class="k">struct</span><span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">Driver</span><span class="p">)</span><span class="n">Accept</span><span class="p">(</span><span class="n">vistor</span><span class="p">){</span>
    <span class="n">vistor</span><span class="o">.</span><span class="n">VistDriver</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上面的示例代码展示了<code class="language-plaintext highlighter-rouge">vistor</code>模式的简单应用。</p>

<h2 id="concurrency-pattern">Concurrency Pattern</h2>

<h3 id="active-object">Active Object</h3>
<p>主动对象模式：使方法执行与驻留在其自己的控制线程中的方法调用脱钩。 目标是通过使用异步方法调用和用于处理请求的调度程序来引入并发。</p>

<p>主动对象模式的实现多种多样，常见的实现方式如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
	<span class="s">"sync"</span>
	<span class="s">"runtime"</span>
	<span class="s">"context"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Runnable</span> <span class="k">func</span><span class="p">()</span>

<span class="k">type</span> <span class="n">ActiveObject</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">list</span>   <span class="k">chan</span> <span class="n">Runnable</span>
	<span class="n">ctx</span>    <span class="n">context</span><span class="o">.</span><span class="n">Context</span>
	<span class="n">cancel</span> <span class="n">context</span><span class="o">.</span><span class="n">CancelFunc</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">ActiveObject</span><span class="p">)</span> <span class="n">Run</span><span class="p">(</span><span class="n">r</span> <span class="n">Runnable</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">a</span><span class="o">.</span><span class="n">list</span> <span class="o">&lt;-</span> <span class="n">r</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">ActiveObject</span><span class="p">)</span> <span class="n">worker</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">running</span> <span class="o">:=</span> <span class="no">true</span><span class="p">;</span> <span class="n">running</span><span class="p">;</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="o">:</span>
			<span class="n">running</span> <span class="o">=</span> <span class="no">false</span>
		<span class="k">case</span> <span class="n">r</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">a</span><span class="o">.</span><span class="n">list</span><span class="o">:</span>
			<span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
				<span class="n">r</span><span class="p">()</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">running</span> <span class="o">=</span> <span class="no">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">ActiveObject</span><span class="p">)</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
	<span class="nb">close</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">list</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">CreateActiveObject</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="o">*</span><span class="n">ActiveObject</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">:=</span> <span class="n">ActiveObject</span><span class="p">{}</span>
	<span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">cancel</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">WithCancel</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
	<span class="n">a</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">Runnable</span><span class="p">,</span> <span class="m">1024</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">NumCPU</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="n">a</span><span class="o">.</span><span class="n">worker</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">a</span>
<span class="p">}</span>

<span class="c">// callers</span>
<span class="k">var</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">CreateActiveObject</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">TODO</span><span class="p">())</span>

<span class="k">func</span> <span class="n">useActive</span><span class="p">(</span><span class="n">r</span> <span class="n">Runnable</span><span class="p">,</span> <span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">obj</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">unUseActive</span><span class="p">(</span><span class="n">r</span> <span class="n">Runnable</span><span class="p">,</span> <span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="n">r</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="m">1024</span><span class="o">*</span><span class="m">1024</span><span class="o">*</span><span class="m">10</span>
	<span class="n">wg</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">{}</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	
	<span class="n">start</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">()</span>
	<span class="c">// useActive(func() {</span>
	<span class="n">unUseActive</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">j</span> <span class="o">:=</span> <span class="m">0</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">*</span><span class="n">i</span>
		<span class="p">}</span> 
		<span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
	<span class="p">},</span> <span class="n">n</span><span class="p">)</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div>
<p>如上面的示例所示，启动了多个worker routines 监听 <code class="language-plaintext highlighter-rouge">list channel</code> 等待 <code class="language-plaintext highlighter-rouge">Runnable</code> 下发。goroutines 的 <code class="language-plaintext highlighter-rouge">GMP</code> 调度器类似上述的active模式，<code class="language-plaintext highlighter-rouge">runnable</code> 和 <code class="language-plaintext highlighter-rouge">worker</code> 对应 <code class="language-plaintext highlighter-rouge">goroutine</code> 和 <code class="language-plaintext highlighter-rouge">thread</code>，只是缺少了<code class="language-plaintext highlighter-rouge">processors</code>这一层，也是golang调度器模型中最复杂的一层。那在 golang中基于<code class="language-plaintext highlighter-rouge">goroutine</code>创建并发调度模型是否有意义？</p>

<p>下面对比下使用主动对象模式和不使用对象模式的效率：</p>

<table>
  <thead>
    <tr>
      <th>NUM</th>
      <th>使用active pattern(ns)</th>
      <th>不使用active pattern(ns)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>4873583000</td>
      <td>3095207000</td>
    </tr>
    <tr>
      <td>2</td>
      <td>4909422000</td>
      <td>3160784000</td>
    </tr>
    <tr>
      <td>3</td>
      <td>5156796000</td>
      <td>3034738000</td>
    </tr>
    <tr>
      <td>4</td>
      <td>5206848000</td>
      <td>3373471000</td>
    </tr>
    <tr>
      <td>5</td>
      <td>4918898000</td>
      <td>3279373000</td>
    </tr>
  </tbody>
</table>

<p>上面的结果显而易见，使用<code class="language-plaintext highlighter-rouge">goroutines pool</code>的并发模型比使用原生的<code class="language-plaintext highlighter-rouge">GMP</code>模型总耗时要多40%，在golang中使用并发模型似乎并不能提高效率？</p>

<p>上面的测试代码中使用了“乘法+加法”的纯cpu运算，以此为基准调整一下单个<code class="language-plaintext highlighter-rouge">Runnable</code>的计算量：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="m">1024</span><span class="o">*</span><span class="m">1024</span><span class="o">*</span><span class="m">10</span>
	<span class="n">wg</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">{}</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	
	<span class="n">start</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">()</span>
	<span class="n">useActive</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// unUseActive(func() {</span>
		<span class="n">j</span> <span class="o">:=</span> <span class="m">0</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">1024</span><span class="o">*</span><span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">*</span><span class="n">i</span>
		<span class="p">}</span> 
		<span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
	<span class="p">},</span> <span class="n">n</span><span class="p">)</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>再次执行测试对比：</p>

<table>
  <thead>
    <tr>
      <th>NUM</th>
      <th>使用active pattern(ns)</th>
      <th>不使用active pattern(ns)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>36332021000</td>
      <td>40188496000</td>
    </tr>
    <tr>
      <td>2</td>
      <td>37933490000</td>
      <td>43609256000</td>
    </tr>
    <tr>
      <td>3</td>
      <td>34902684000</td>
      <td>44315337000</td>
    </tr>
    <tr>
      <td>4</td>
      <td>35616489000</td>
      <td>37804656000</td>
    </tr>
    <tr>
      <td>5</td>
      <td>35273675000</td>
      <td>42551568000</td>
    </tr>
  </tbody>
</table>

<p>在计算量提高了<code class="language-plaintext highlighter-rouge">10</code>倍之后，运行测试的主机cpu跑満后，使用<code class="language-plaintext highlighter-rouge">goroutines pool</code>要优于原生的<code class="language-plaintext highlighter-rouge">GMP</code>。</p>

<p>具体的内部耗时可以用golang原生的profile去分析一下，首先我们在代码里加入可以生成<code class="language-plaintext highlighter-rouge">cpu profile</code> 的代码：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="m">1024</span> <span class="o">*</span> <span class="m">1024</span> <span class="o">*</span> <span class="m">10</span>
    <span class="n">wg</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">{}</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">start</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">enable</span> <span class="o">:=</span> <span class="no">true</span><span class="p">;</span> <span class="n">enable</span> <span class="p">{</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">OpenFile</span><span class="p">(</span><span class="s">"parrel.pprof"</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_CREATE</span><span class="o">|</span><span class="n">os</span><span class="o">.</span><span class="n">O_RDWR</span><span class="p">,</span> <span class="m">0600</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">defer</span> <span class="n">w</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>

        <span class="n">pprof</span><span class="o">.</span><span class="n">StartCPUProfile</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">defer</span> <span class="n">pprof</span><span class="o">.</span><span class="n">StopCPUProfile</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">useActive</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c">// unUseActive(func() {</span>
        <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">1024</span><span class="o">*</span><span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">i</span>
        <span class="p">}</span>
        <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
    <span class="p">},</span> <span class="n">n</span><span class="p">)</span>

    <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>针对两种情况进行<code class="language-plaintext highlighter-rouge">cpu profile</code>分析，首先来看使用了<code class="language-plaintext highlighter-rouge">goroutines pool</code>的：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ype: cpu
Time: Jun 15, 2021 at 8:07pm (CST)
Duration: 38.02s, Total samples = 7.19mins (1134.18%)
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) top 10
Showing nodes accounting for 426.48s, 98.91% of 431.18s total
Dropped 88 nodes (cum &lt;= 2.16s)
Showing top 10 nodes out of 21
      flat  flat%   sum%        cum   cum%
   329.75s 76.48% 76.48%    352.28s 81.70%  main.main.func1
    67.35s 15.62% 92.10%     67.35s 15.62%  runtime.usleep
    21.81s  5.06% 97.15%     21.81s  5.06%  runtime.asyncPreempt
     3.41s  0.79% 97.95%      3.41s  0.79%  runtime.pthread_cond_wait
     2.94s  0.68% 98.63%    372.65s 86.43%  main.(*ActiveObject).worker
     0.40s 0.093% 98.72%     15.27s  3.54%  runtime.lock2
     0.38s 0.088% 98.81%     17.27s  4.01%  runtime.selectgo
     0.26s  0.06% 98.87%     15.38s  3.57%  runtime.sellock
     0.10s 0.023% 98.89%     56.95s 13.21%  runtime.findrunnable
     0.08s 0.019% 98.91%     53.27s 12.35%  runtime.runqgrab
(pprof) tree
Showing nodes accounting for 426.53s, 98.92% of 431.18s total
Dropped 88 nodes (cum &lt;= 2.16s)
----------------------------------------------------------+-------------
      flat  flat%   sum%        cum   cum%   calls calls% + context              
----------------------------------------------------------+-------------
                                           352.28s   100% |   main.(*ActiveObject).worker
   329.75s 76.48% 76.48%    352.28s 81.70%                | main.main.func1
                                            21.81s  6.19% |   runtime.asyncPreempt
----------------------------------------------------------+-------------
                                            53.19s 78.98% |   runtime.runqgrab
                                            14.16s 21.02% |   runtime.osyield
    67.35s 15.62% 92.10%     67.35s 15.62%                | runtime.usleep
----------------------------------------------------------+-------------
                                            21.81s   100% |   main.main.func1
    21.81s  5.06% 97.15%     21.81s  5.06%                | runtime.asyncPreempt
----------------------------------------------------------+-------------
                                             3.41s   100% |   runtime.semasleep
     3.41s  0.79% 97.95%      3.41s  0.79%                | runtime.pthread_cond_wait
----------------------------------------------------------+-------------
     2.94s  0.68% 98.63%    372.65s 86.43%                | main.(*ActiveObject).worker
                                           352.28s 94.53% |   main.main.func1
                                            17.27s  4.63% |   runtime.selectgo
----------------------------------------------------------+-------------
                                            15.27s   100% |   runtime.lockWithRank
     0.40s 0.093% 98.72%     15.27s  3.54%                | runtime.lock2
                                            14.16s 92.73% |   runtime.osyield (inline)
----------------------------------------------------------+-------------
                                            17.27s   100% |   main.(*ActiveObject).worker
     0.38s 0.088% 98.81%     17.27s  4.01%                | runtime.selectgo
                                            15.38s 89.06% |   runtime.sellock
----------------------------------------------------------+-------------
                                            15.38s   100% |   runtime.selectgo
     0.26s  0.06% 98.87%     15.38s  3.57%                | runtime.sellock
                                            15.12s 98.31% |   runtime.lock (inline)
----------------------------------------------------------+-------------
                                            56.95s   100% |   runtime.schedule
     0.10s 0.023% 98.89%     56.95s 13.21%                | runtime.findrunnable
                                            53.28s 93.56% |   runtime.runqsteal
                                             3.43s  6.02% |   runtime.stopm
----------------------------------------------------------+-------------
                                            53.27s   100% |   runtime.runqsteal
     0.08s 0.019% 98.91%     53.27s 12.35%                | runtime.runqgrab
                                            53.19s 99.85% |   runtime.usleep
----------------------------------------------------------+-------------
                                            57.13s 99.81% |   runtime.park_m
     0.02s 0.0046% 98.91%     57.24s 13.28%                | runtime.schedule
                                            56.95s 99.49% |   runtime.findrunnable
----------------------------------------------------------+-------------
                                            57.27s   100% |   runtime.mcall
     0.01s 0.0023% 98.92%     57.27s 13.28%                | runtime.park_m
                                            57.13s 99.76% |   runtime.schedule
----------------------------------------------------------+-------------
                                            53.28s   100% |   runtime.findrunnable
     0.01s 0.0023% 98.92%     53.28s 12.36%                | runtime.runqsteal
                                            53.27s   100% |   runtime.runqgrab
----------------------------------------------------------+-------------
                                             3.43s   100% |   runtime.findrunnable
     0.01s 0.0023% 98.92%      3.43s   0.8%                | runtime.stopm
                                             3.41s 99.42% |   runtime.mPark
----------------------------------------------------------+-------------
                                            15.12s 99.08% |   runtime.sellock (inline)
         0     0% 98.92%     15.26s  3.54%                | runtime.lock
                                            15.26s   100% |   runtime.lockWithRank (inline)
----------------------------------------------------------+-------------
                                            15.26s 99.93% |   runtime.lock (inline)
         0     0% 98.92%     15.27s  3.54%                | runtime.lockWithRank
                                            15.27s   100% |   runtime.lock2
----------------------------------------------------------+-------------
                                             3.41s   100% |   runtime.stopm
         0     0% 98.92%      3.41s  0.79%                | runtime.mPark
                                             3.41s   100% |   runtime.notesleep
----------------------------------------------------------+-------------
         0     0% 98.92%     57.27s 13.28%                | runtime.mcall
                                            57.27s   100% |   runtime.park_m
----------------------------------------------------------+-------------
                                             3.41s   100% |   runtime.mPark
         0     0% 98.92%      3.41s  0.79%                | runtime.notesleep
                                             3.41s   100% |   runtime.semasleep
----------------------------------------------------------+-------------
                                            14.16s   100% |   runtime.lock2 (inline)
         0     0% 98.92%     14.16s  3.28%                | runtime.osyield
                                            14.16s   100% |   runtime.usleep
----------------------------------------------------------+-------------
                                             3.41s   100% |   runtime.notesleep
         0     0% 98.92%      3.41s  0.79%                | runtime.semasleep
                                             3.41s   100% |   runtime.pthread_cond_wait
----------------------------------------------------------+-------------
(pprof) list main.main.func1
Total: 7.19mins
ROUTINE ======================== main.main.func1 in /Users/wangzhipeng/workspace/newbee/golang/tmp/design_pattern/parral.go
  5.50mins   5.87mins (flat, cum) 81.70% of Total
         .          .     85:
         .          .     86:           pprof.StartCPUProfile(w)
         .          .     87:           defer pprof.StopCPUProfile()
         .          .     88:   }
         .          .     89:
         .       20ms     90:   // useActive(func() {
         .          .     91:   unUseActive(func() {
         .          .     92:           j := 0
  5.50mins   5.86mins     93:           for i := 0; i &lt; 1024*100; i++ {
         .          .     94:                   j = j * i
         .          .     95:           }
         .      710ms     96:           wg.Done()
         .          .     97:   }, n)
         .          .     98:
         .          .     99:   wg.Wait()
         .          .    100:   start = time.Now().UnixNano() - start
         .          .    101:   fmt.Println(start)
</code></pre></div></div>

<p>然后再来看一下不使用<code class="language-plaintext highlighter-rouge">goroutines pool</code>的：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Type: cpu
Time: Jun 15, 2021 at 8:13pm (CST)
Duration: 52.76s, Total samples = 10.53mins (1197.83%)
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) top 10
Showing nodes accounting for 10.29mins, 97.64% of 10.53mins total
Dropped 172 nodes (cum &lt;= 0.05mins)
Showing top 10 nodes out of 39
      flat  flat%   sum%        cum   cum%
  7.75mins 73.54% 73.54%   7.76mins 73.66%  main.main.func1
  1.52mins 14.44% 87.98%   1.52mins 14.44%  runtime/pprof.lostProfileEvent
  0.27mins  2.52% 90.50%   0.32mins  3.00%  runtime.execute
  0.17mins  1.57% 92.07%   0.17mins  1.60%  runtime.gentraceback
  0.16mins  1.55% 93.62%   0.17mins  1.62%  runtime.findnull
  0.14mins  1.36% 94.99%   0.14mins  1.36%  runtime.(*gQueue).pop (inline)
  0.10mins  0.92% 95.91%   0.10mins  0.92%  runtime.usleep
  0.08mins  0.72% 96.63%   0.85mins  8.06%  runtime.goexit0
  0.06mins  0.53% 97.17%   0.07mins  0.62%  runtime.gcWriteBarrier
  0.05mins  0.48% 97.64%   0.07mins  0.66%  runtime.stackpoolalloc
(pprof) tree
Showing nodes accounting for 621.92s, 98.41% of 632s total
Dropped 172 nodes (cum &lt;= 3.16s)
----------------------------------------------------------+-------------
      flat  flat%   sum%        cum   cum%   calls calls% + context              
----------------------------------------------------------+-------------
   464.76s 73.54% 73.54%    465.52s 73.66%                | main.main.func1
----------------------------------------------------------+-------------
    91.28s 14.44% 87.98%     91.28s 14.44%                | runtime/pprof.lostProfileEvent
----------------------------------------------------------+-------------
                                            18.93s   100% |   runtime.schedule
    15.92s  2.52% 90.50%     18.93s  3.00%                | runtime.execute
                                             2.89s 15.27% |   runtime.gcWriteBarrier
----------------------------------------------------------+-------------
                                            10.14s   100% |   runtime.scanstack
     9.93s  1.57% 92.07%     10.14s  1.60%                | runtime.gentraceback
----------------------------------------------------------+-------------
                                            10.22s   100% |   runtime.gostringnocopy
     9.82s  1.55% 93.62%     10.22s  1.62%                | runtime.findnull
----------------------------------------------------------+-------------
                                             8.62s   100% |   runtime.globrunqget (inline)
     8.62s  1.36% 94.99%      8.62s  1.36%                | runtime.(*gQueue).pop
----------------------------------------------------------+-------------
                                             5.84s   100% |   runtime.osyield
     5.84s  0.92% 95.91%      5.84s  0.92%                | runtime.usleep
----------------------------------------------------------+-------------
                                            50.91s   100% |   runtime.mcall
     4.55s  0.72% 96.63%     50.91s  8.06%                | runtime.goexit0
                                            31.37s 61.62% |   runtime.schedule
                                            10.78s 21.17% |   runtime.isSystemGoroutine
                                             2.86s  5.62% |   runtime.lock (inline)
                                             1.01s  1.98% |   runtime.gcWriteBarrier
----------------------------------------------------------+-------------
                                             2.89s 74.10% |   runtime.execute
                                             1.01s 25.90% |   runtime.goexit0
     3.37s  0.53% 97.17%      3.90s  0.62%                | runtime.gcWriteBarrier
----------------------------------------------------------+-------------
                                             4.19s   100% |   runtime.stackcacherefill
     3.01s  0.48% 97.64%      4.19s  0.66%                | runtime.stackpoolalloc
----------------------------------------------------------+-------------
                                             3.83s   100% |   runtime.gcDrain
     2.16s  0.34% 97.98%      3.83s  0.61%                | runtime.scanobject
----------------------------------------------------------+-------------
                                             8.32s   100% |   runtime.newproc.func1
     0.75s  0.12% 98.10%      8.32s  1.32%                | runtime.newproc1
                                             5.60s 67.31% |   runtime.malg
----------------------------------------------------------+-------------
                                            10.78s 96.77% |   runtime.goexit0
     0.38s  0.06% 98.16%     11.14s  1.76%                | runtime.isSystemGoroutine
                                            10.40s 93.36% |   runtime.funcname
----------------------------------------------------------+-------------
                                             4.31s   100% |   runtime.malg
     0.35s 0.055% 98.22%      4.31s  0.68%                | runtime.malg.func1
                                             3.96s 91.88% |   runtime.stackalloc
----------------------------------------------------------+-------------
                                            11.03s   100% |   runtime.gcDrain
     0.33s 0.052% 98.27%     11.03s  1.75%                | runtime.markroot
                                            10.37s 94.02% |   runtime.markroot.func1
----------------------------------------------------------+-------------
                                            31.37s   100% |   runtime.goexit0
     0.23s 0.036% 98.31%     31.38s  4.97%                | runtime.schedule
                                            18.93s 60.33% |   runtime.execute
                                             9.49s 30.24% |   runtime.findrunnable
                                             1.97s  6.28% |   runtime.lock (inline)
----------------------------------------------------------+-------------
                                            15.03s   100% |   runtime.gcBgMarkWorker.func2
     0.16s 0.025% 98.33%     15.03s  2.38%                | runtime.gcDrain
                                            11.03s 73.39% |   runtime.markroot
                                             3.83s 25.48% |   runtime.scanobject
----------------------------------------------------------+-------------
     0.10s 0.016% 98.35%     51.02s  8.07%                | runtime.mcall
                                            50.91s 99.78% |   runtime.goexit0
----------------------------------------------------------+-------------
                                             6.71s   100% |   main.unUseActive
     0.06s 0.0095% 98.36%      6.71s  1.06%                | runtime.newproc
                                             6.65s 99.11% |   runtime.systemstack
----------------------------------------------------------+-------------
                                            10.27s   100% |   runtime.funcname (inline)
     0.05s 0.0079% 98.37%     10.27s  1.62%                | runtime.gostringnocopy
                                            10.22s 99.51% |   runtime.findnull
----------------------------------------------------------+-------------
                                             6.01s   100% |   runtime.lockWithRank
     0.05s 0.0079% 98.37%      6.01s  0.95%                | runtime.lock2
                                             5.84s 97.17% |   runtime.osyield (inline)
----------------------------------------------------------+-------------
                                            15.04s 62.88% |   runtime.gcBgMarkWorker
                                             6.65s 27.80% |   runtime.newproc
     0.04s 0.0063% 98.38%     23.92s  3.78%                | runtime.systemstack
                                            15.03s 62.83% |   runtime.gcBgMarkWorker.func2
                                             8.47s 35.41% |   runtime.newproc.func1
----------------------------------------------------------+-------------
                                            10.40s   100% |   runtime.isSystemGoroutine
     0.03s 0.0047% 98.38%     10.40s  1.65%                | runtime.funcname
                                            10.27s 98.75% |   runtime.gostringnocopy (inline)
----------------------------------------------------------+-------------
                                            10.37s   100% |   runtime.markroot
     0.02s 0.0032% 98.39%     10.37s  1.64%                | runtime.markroot.func1
                                            10.23s 98.65% |   runtime.scanstack
----------------------------------------------------------+-------------
                                            10.23s   100% |   runtime.markroot.func1
     0.02s 0.0032% 98.39%     10.23s  1.62%                | runtime.scanstack
                                            10.14s 99.12% |   runtime.gentraceback
----------------------------------------------------------+-------------
                                             3.96s 93.40% |   runtime.malg.func1
     0.02s 0.0032% 98.39%      4.24s  0.67%                | runtime.stackalloc
                                             4.22s 99.53% |   runtime.stackcacherefill
----------------------------------------------------------+-------------
                                             4.22s   100% |   runtime.stackalloc
     0.02s 0.0032% 98.40%      4.22s  0.67%                | runtime.stackcacherefill
                                             4.19s 99.29% |   runtime.stackpoolalloc
----------------------------------------------------------+-------------
                                             9.49s   100% |   runtime.schedule
     0.01s 0.0016% 98.40%      9.49s  1.50%                | runtime.findrunnable
                                             8.37s 88.20% |   runtime.globrunqget
                                             0.98s 10.33% |   runtime.lock (inline)
----------------------------------------------------------+-------------
                                             8.37s 95.99% |   runtime.findrunnable
     0.01s 0.0016% 98.40%      8.72s  1.38%                | runtime.globrunqget
                                             8.62s 98.85% |   runtime.(*gQueue).pop (inline)
----------------------------------------------------------+-------------
                                             6.02s   100% |   runtime.lock (inline)
     0.01s 0.0016% 98.40%      6.02s  0.95%                | runtime.lockWithRank
                                             6.01s 99.83% |   runtime.lock2
----------------------------------------------------------+-------------
                                             5.60s   100% |   runtime.newproc1
     0.01s 0.0016% 98.40%      5.60s  0.89%                | runtime.malg
                                             4.31s 76.96% |   runtime.malg.func1
----------------------------------------------------------+-------------
                                             8.47s   100% |   runtime.systemstack
     0.01s 0.0016% 98.41%      8.47s  1.34%                | runtime.newproc.func1
                                             8.32s 98.23% |   runtime.newproc1
----------------------------------------------------------+-------------
                                             6.71s   100% |   runtime.main
         0     0% 98.41%      6.71s  1.06%                | main.main
                                             6.71s   100% |   main.unUseActive
----------------------------------------------------------+-------------
                                             6.71s   100% |   main.main
         0     0% 98.41%      6.71s  1.06%                | main.unUseActive
                                             6.71s   100% |   runtime.newproc
----------------------------------------------------------+-------------
         0     0% 98.41%     15.05s  2.38%                | runtime.gcBgMarkWorker
                                            15.04s 99.93% |   runtime.systemstack
----------------------------------------------------------+-------------
                                            15.03s   100% |   runtime.systemstack
         0     0% 98.41%     15.03s  2.38%                | runtime.gcBgMarkWorker.func2
                                            15.03s   100% |   runtime.gcDrain
----------------------------------------------------------+-------------
                                             2.86s 47.51% |   runtime.goexit0 (inline)
                                             1.97s 32.72% |   runtime.schedule (inline)
                                             0.98s 16.28% |   runtime.findrunnable (inline)
         0     0% 98.41%      6.02s  0.95%                | runtime.lock
                                             6.02s   100% |   runtime.lockWithRank (inline)
----------------------------------------------------------+-------------
         0     0% 98.41%      6.71s  1.06%                | runtime.main
                                             6.71s   100% |   main.main
----------------------------------------------------------+-------------
                                             5.84s   100% |   runtime.lock2 (inline)
         0     0% 98.41%      5.84s  0.92%                | runtime.osyield
                                             5.84s   100% |   runtime.usleep
----------------------------------------------------------+-------------
(pprof) list main.main.func1
Total: 10.53mins
ROUTINE ======================== main.main.func1 in /Users/wangzhipeng/workspace/newbee/golang/tmp/design_pattern/parral.go
  7.75mins   7.76mins (flat, cum) 73.66% of Total
         .          .     86:           pprof.StartCPUProfile(w)
         .          .     87:           defer pprof.StopCPUProfile()
         .          .     88:   }
         .          .     89:
         .          .     90:   // useActive(func() {
  1.73mins   1.73mins     91:   unUseActive(func() {
         .          .     92:           j := 0
  6.02mins   6.02mins     93:           for i := 0; i &lt; 1024*100; i++ {
         .          .     94:                   j = j * i
         .          .     95:           }
         .      720ms     96:           wg.Done()
         .          .     97:   }, n)
         .          .     98:
         .          .     99:   wg.Wait()
         .          .    100:   start = time.Now().UnixNano() - start
         .          .    101:   fmt.Println(start)
</code></pre></div></div>
<p>由开启了<code class="language-plaintext highlighter-rouge">profile</code>会对协程调度的开销有所影响， 对于后者来讲带来的损耗会更大，因为后者要创建大量的协程。最消耗<code class="language-plaintext highlighter-rouge">cpu</code>的明显是<code class="language-plaintext highlighter-rouge">f</code>，其余部分的抛开<code class="language-plaintext highlighter-rouge">runtime/pprof.lostProfileEvent</code>，前者集中在因为<code class="language-plaintext highlighter-rouge">selectgo</code>(4.01%)和<code class="language-plaintext highlighter-rouge">runtime.park_m</code>(13.28%)引起的开销，后者主要集中在<code class="language-plaintext highlighter-rouge">go.exit()</code>(8.06%)和<code class="language-plaintext highlighter-rouge">runtime.newproc</code>引起的<code class="language-plaintext highlighter-rouge">runtime.systemstack</code>的调用（1.06%）。需要注意的是上面是没有扣除<code class="language-plaintext highlighter-rouge">profile</code>引入的额外损耗下的百分比，在实际情况下后者的耗时占比会上升。</p>

<p>golang中创建<code class="language-plaintext highlighter-rouge">goroutine</code>的开销要远小于创建<code class="language-plaintext highlighter-rouge">thread</code>的开销，但也是需要一定开销的：</p>
<ol>
  <li>go 命令创建 <code class="language-plaintext highlighter-rouge">goroutine</code> 可能会触发调度器进行调度。要选择一个 processor加入其队列中，如果所有processor的队列都已经充满，它会加入到全局队列中等待执行；</li>
  <li>
<code class="language-plaintext highlighter-rouge">goroutine</code>最起码要分配2k栈空间（golang 1.12 版本中，最大空间取决于操作系统位数，32位系统中最大 250M，64位操作系统中最大 1G），需要内存开销。虽然golang中采取了一些优化措施，在<code class="language-plaintext highlighter-rouge">goroutine end-of-life</code>时会将其加入一个<code class="language-plaintext highlighter-rouge">internel pool</code>中，<code class="language-plaintext highlighter-rouge">new goroutine</code>会从池中捞取进行重用，但那只针对栈空间没有被拓展过的<code class="language-plaintext highlighter-rouge">goroutine</code>(验证代码未起到对应效果)；</li>
  <li>采用一个类似<code class="language-plaintext highlighter-rouge">goroutines pool</code>的并发模型，可以任务抑制并发执行数量，因为同时只有<code class="language-plaintext highlighter-rouge">n</code>个<code class="language-plaintext highlighter-rouge">worker</code>在执行。对于高并发且会执行大量内存申请操作的场景下，采用<code class="language-plaintext highlighter-rouge">goroutines pool</code>的模型可以有效抑制内存和cpu。</li>
</ol>

<p>Note: 需要注意的是，当申请一个过大的连续内存空间（例如 make([]int, 10240)）时，会被分配在堆上，及时它没有脱离申请函数的生命周期。</p>

<h3 id="double-checked-locking">Double-checked locking</h3>

<p>双重检查加锁优化：在加锁前进行检查判断是否需要加锁保护，避免不必要加锁带来的额外开销。
<strong>使用场景</strong>：它通常用于在多线程环境中实现“延迟初始化”时减少锁定开销，尤其是作为单例模式的一部分。延迟初始化避免在第一次访问值之前对其进行初始化。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"sync"</span>

<span class="k">var</span> <span class="n">arrOnce</span> <span class="n">sync</span><span class="o">.</span><span class="n">Once</span>
<span class="k">var</span> <span class="n">arr</span> <span class="p">[]</span><span class="kt">int</span>

<span class="c">// getArr retrieves arr, lazily initializing on first call. Double-checked</span>
<span class="c">// locking is implemented with the sync.Once library function. The first</span>
<span class="c">// goroutine to win the race to call Do() will initialize the array, while</span>
<span class="c">// others will block until Do() has completed. After Do has run, only a</span>
<span class="c">// single atomic comparison will be required to get the array.</span>
<span class="k">func</span> <span class="n">getArr</span><span class="p">()</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">arrOnce</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
	<span class="p">})</span>
	<span class="k">return</span> <span class="n">arr</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// thanks to double-checked locking, two goroutines attempting to getArr()</span>
	<span class="c">// will not cause double-initialization</span>
	<span class="k">go</span> <span class="n">getArr</span><span class="p">()</span>
	<span class="k">go</span> <span class="n">getArr</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在上面<code class="language-plaintext highlighter-rouge">lazy initial</code>的模式时已经讲过这种使用方法了，这里使用<code class="language-plaintext highlighter-rouge">sync.Once</code>有两个好处：</p>
<ol>
  <li>只会执行一次，如果执行过了，下次调用不会重复执行；</li>
  <li>并发调用的时候有锁保护，保证不会重复执行；
综上即只会在第一次调用的时候执行初始化，且只执行一次。</li>
</ol>

<p>下面简单讲一下<code class="language-plaintext highlighter-rouge">sync.Once</code>是如何实现的该功能，后面会单独对其进行详细的解析。</p>
<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Once</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// done indicates whether the action has been performed.</span>
	<span class="c">// It is first in the struct because it is used in the hot path.</span>
	<span class="c">// The hot path is inlined at every call site.</span>
	<span class="c">// Placing done first allows more compact instructions on some architectures (amd64/386),</span>
	<span class="c">// and fewer instructions (to calculate offset) on other architectures.</span>
	<span class="n">done</span> <span class="kt">uint32</span>
	<span class="n">m</span>    <span class="n">Mutex</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">o</span> <span class="o">*</span><span class="n">Once</span><span class="p">)</span> <span class="n">Do</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">.</span><span class="n">done</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">o</span><span class="o">.</span><span class="n">doSlow</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">o</span> <span class="o">*</span><span class="n">Once</span><span class="p">)</span> <span class="n">doSlow</span><span class="p">(</span><span class="n">f</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="n">o</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">o</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">done</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">atomic</span><span class="o">.</span><span class="n">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">.</span><span class="n">done</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
		<span class="n">f</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>结构体中成员变量：</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">done</code>是用来标记是否已经执行过，它保证了上述第一个好处；</li>
  <li>
<code class="language-plaintext highlighter-rouge">m</code>是用来做并发保护的<code class="language-plaintext highlighter-rouge">sync.Mutext</code>，它保证了上述的第一个好处；</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">once.Done(f func())</code>的流程如下：</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiZ3JhcGggVERcblN0YXJ0W3N0YXJ0XTtcbklzRmlyc3R7bG9hZCBkb25lIGluIGF0b21pYywgZG9uZSA9PTAgP307XG5Mb2NrW20ubG9ja107XG5VbmxvY2tbbS51bmxvY2tdO1xuSXNOb3REb25leyBkb25lPT0wPyB9O1xuRnVuY1tydW4gZnVuY3Rpb25dO1xuRG9uZVsgc2V0IGRvbmUgPSAxIGluIGF0b21pY107XG5FbmRbZW5kXTtcbiUlLVxuU3RhcnQtLT5Jc0ZpcnN0O1xuSXNGaXJzdC0tPnxOb3xFbmQ7XG5Jc0ZpcnN0LS0-fFllc3xMb2NrO1xuTG9jay0tPklzTm90RG9uZTtcbklzTm90RG9uZS0tPnxZZXN8RnVuYztGdW5jLS0-RG9uZTtEb25lLS0-VW5sb2NrO1xuSXNOb3REb25lLS0-fE5vdHxVbmxvY2s7XG5VbmxvY2stLT5FbmQ7IiwibWVybWFpZCI6bnVsbH0"></p>

<p>这里面有几个关键的点需要注意一下：</p>
<ol>
  <li>在<code class="language-plaintext highlighter-rouge">m</code>锁保护的情况下使用<code class="language-plaintext highlighter-rouge">atomic.StoreUint32(&amp;o.done, 1)</code>修改值，这是为了使<code class="language-plaintext highlighter-rouge">Done</code>状态立刻生效，虽然此时<code class="language-plaintext highlighter-rouge">m</code>还未被释放，但是<code class="language-plaintext highlighter-rouge">f</code>已经执行完毕了。</li>
  <li>拆分出<code class="language-plaintext highlighter-rouge">doSlow</code>函数是为了<code class="language-plaintext highlighter-rouge">Done</code>函数可以在编译时内联优化，这样执行起来速度更快的判断<code class="language-plaintext highlighter-rouge">Done</code>的状态。</li>
</ol>

<h3 id="monitor">Monitor</h3>

<p>监视器模式：监视器模式是并发编程中一种资源保护模式，它通常由<code class="language-plaintext highlighter-rouge">mutex</code>和<code class="language-plaintext highlighter-rouge">condition</code>共同组成，它允许调用者放弃对<code class="language-plaintext highlighter-rouge">mutex</code>的占用，等待满足特定条件下才会触发对资源的独占访问，同时也可以发出信号唤醒一些等待条件的调用方（thread、goroutine、process等等）。</p>

<p>在golang中实现起来有多种方案，可以直接使用<code class="language-plaintext highlighter-rouge">sync.Cond</code>和<code class="language-plaintext highlighter-rouge">sync.Mutex</code>来实现一个简单版本监视器模式：</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Queue</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">buff</span>  <span class="p">[]</span><span class="kt">int</span>
	<span class="n">read</span>  <span class="kt">int</span>
	<span class="n">write</span> <span class="kt">int</span>

	<span class="n">m</span>    <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
	<span class="n">cond</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span><span class="n">Queue</span><span class="p">)</span> <span class="n">isFull</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">write</span><span class="o">+</span><span class="m">1</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">buff</span><span class="p">)</span> <span class="o">==</span> <span class="n">q</span><span class="o">.</span><span class="n">read</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span><span class="n">Queue</span><span class="p">)</span> <span class="n">isEmpty</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="n">write</span> <span class="o">==</span> <span class="n">q</span><span class="o">.</span><span class="n">read</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span><span class="n">Queue</span><span class="p">)</span> <span class="n">Push</span><span class="p">(</span><span class="n">e</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">q</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">q</span><span class="o">.</span><span class="n">isFull</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">.</span><span class="n">buff</span><span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">write</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
	<span class="n">q</span><span class="o">.</span><span class="n">write</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">write</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">buff</span><span class="p">)</span>
	<span class="n">q</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span>

	<span class="n">q</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span><span class="n">Queue</span><span class="p">)</span> <span class="n">Pop</span><span class="p">()</span> <span class="p">(</span><span class="n">res</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">q</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">q</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">buff</span><span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">read</span><span class="p">]</span>
	<span class="n">q</span><span class="o">.</span><span class="n">read</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">read</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">buff</span><span class="p">)</span>
	<span class="n">q</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span>
	<span class="n">q</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上面是一个简单的<code class="language-plaintext highlighter-rouge">ring buffer</code>实现，主要是依赖于<code class="language-plaintext highlighter-rouge">sync.Cond</code>的强大功能，这里对它的实现做一个简单的解析：</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Cond</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">noCopy</span> <span class="n">noCopy</span>

    <span class="c">// L is held while observing or changing the condition</span>
    <span class="n">L</span> <span class="n">Locker</span> <span class="c">// 资源保护锁，可以为sync.Mutex或sync.RWMutex</span>

    <span class="n">notify</span>  <span class="n">notifyList</span> <span class="c">// 通知列表</span>
    <span class="n">checker</span> <span class="n">copyChecker</span>
<span class="p">}</span>

<span class="c">// 等待信号</span>
<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Cond</span><span class="p">)</span> <span class="n">Wait</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">checker</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="c">// 将当前的goroutine加入通知列表，返回一个ticket number；</span>
    <span class="n">t</span> <span class="o">:=</span> <span class="n">runtime_notifyListAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">notify</span><span class="p">)</span>
    <span class="c">// 释放独占锁；</span>
    <span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="c">// 根据ticket number 等待被通知，此处在接收信号前会blokced；</span>
    <span class="n">runtime_notifyListWait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">notify</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="c">// 获取独占锁；</span>
    <span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// 发送信号并唤醒一个等待队列中的 g</span>
<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Cond</span><span class="p">)</span> <span class="n">Signal</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">checker</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="n">runtime_notifyListNotifyOne</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">notify</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// 唤醒等待队列中所有的g</span>
<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Cond</span><span class="p">)</span> <span class="n">Broadcast</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">checker</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="n">runtime_notifyListNotifyAll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">notify</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// notifyList 基于ticket实现的一个通知链表，它被 sync.Cond 依赖.</span>
<span class="c">//</span>
<span class="c">// It must be kept in sync with the sync package.</span>
<span class="k">type</span> <span class="n">notifyList</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// 下一waiter的tickt number，在lock保护外原子累加</span>
    <span class="n">wait</span> <span class="kt">uint32</span>

    <span class="c">// 下一个被通知的waiter的ticket number，</span>
    <span class="c">// 它可以在lock保护外读取，但只能在lock保护内写入。</span>
    <span class="c">// wait 和 notify都可能“越界”（即累加超过2^32-1），</span>
    <span class="c">// 只要它们的真实“差距”（wait - notify）不超过（2^31），</span>
    <span class="c">// 这在目前是不可能的，因为同时存在的g不可能超过 2^31。</span>
    <span class="n">notify</span> <span class="kt">uint32</span>

    <span class="c">// List of parked waiters，它是一个单向指针链表.</span>
    <span class="n">lock</span> <span class="n">mutex</span> <span class="c">// 互斥保护</span>
    <span class="n">head</span> <span class="o">*</span><span class="n">sudog</span>  <span class="c">// waiters list 头指针，sudo是用于在等待列表中表示一个 g (goroutine)，它也被channel实现依赖</span>
    <span class="n">tail</span> <span class="o">*</span><span class="n">sudog</span> <span class="c">// waiters list 尾指针</span>
<span class="p">}</span>

<span class="c">// runtime_notifyListAdd 实现，在runtime/sema.go中，</span>
<span class="c">// 通过linkname进行连接</span>
<span class="c">//go:linkname notifyListAdd sync.runtime_notifyListAdd</span>
<span class="k">func</span> <span class="n">notifyListAdd</span><span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">notifyList</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
    <span class="c">// 当sync.Cond.Wait 以 read 模式占用一个RWMutex时，</span>
    <span class="c">// 此函数可能会被并发调用.</span>
    <span class="c">// Note: 返回当前l.wait的值，并将l.wait+1</span>
    <span class="k">return</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">wait</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span>
<span class="p">}</span>

<span class="c">// runtime_notifyListWait 实现，在runtime/sema.go中，</span>
<span class="c">// 过linkname进行连接</span>
<span class="c">// notifyListWait 会等待一个通知，如果一个通知在已经在notifyListAdd</span>
<span class="c">// 前发送它会立即返回，否则它会block.</span>
<span class="c">//go:linkname notifyListWait sync.runtime_notifyListWait</span>
<span class="k">func</span> <span class="n">notifyListWait</span><span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">notifyList</span><span class="p">,</span> <span class="n">t</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lockWithRank</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">lockRankNotifyList</span><span class="p">)</span>

    <span class="c">// Return right away if this ticket has already been notified.</span>
    <span class="c">// int32(t-l.notify) &lt; 0</span>
    <span class="c">// 考虑到两者都可能越界，但是它们的差异不会超过`2^31`</span>
    <span class="c">// 如果小于notify则立即返回</span>
    <span class="k">if</span> <span class="n">less</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">notify</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c">// Enqueue itself.</span>
    <span class="c">// sudog 绑定 ticket number 与 g，压入 waiter list.</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="n">acquireSudog</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">getg</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">ticket</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">s</span><span class="o">.</span><span class="n">releasetime</span> <span class="o">=</span> <span class="m">0</span>
    <span class="n">t0</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">blockprofilerate</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">cputicks</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">releasetime</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">s</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">l</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span>
    <span class="p">}</span>
    <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">s</span>
    <span class="c">// 挂起 g并释放l.lock，可以通过 goready(g)唤醒</span>
    <span class="c">// 此处goroutine会进入挂起状态</span>
    <span class="n">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">waitReasonSyncCondWait</span><span class="p">,</span> <span class="n">traceEvGoBlockCond</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t0</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">blockevent</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">releasetime</span><span class="o">-</span><span class="n">t0</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 释放对象 s</span>
    <span class="n">releaseSudog</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// runtime_notifyListNotifyOne 实现，在runtime/sema.go中，</span>
<span class="c">// 过linkname进行连接</span>
<span class="c">// notifyListNotifyOne 唤醒一个在waiter list 的 g</span>
<span class="c">//go:linkname notifyListNotifyOne sync.runtime_notifyListNotifyOne</span>
<span class="k">func</span> <span class="n">notifyListNotifyOne</span><span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">notifyList</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Fast-path: 自从上一次通知发送后，没有新的waiter进入队列；</span>
    <span class="c">// 直接返回，不进入唤醒流程。</span>
    <span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">wait</span><span class="p">)</span> <span class="o">==</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">notify</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">lockWithRank</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">lockRankNotifyList</span><span class="p">)</span>

    <span class="c">// 进行二次检查.</span>
    <span class="n">t</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">notify</span>
    <span class="c">// 此处使用atomic.Load 是因为l.wait在notifyListAdd</span>
    <span class="c">// 中并未使用l.lock保护自增，而是通过原子操作。</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c">// 更新通知编号.</span>
    <span class="c">// 此处使用原子操作因为l.notify的读取有不在l.lock保护的情况</span>
    <span class="c">// 如上面的FastPath </span>
    <span class="n">atomic</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">notify</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>

    <span class="c">// 寻找需要唤醒的g，有可能它刚刚调用notifyListAdd() 还未来得及</span>
    <span class="c">// 调用notifyListWait()将自己加入到 waiter list，但是当它</span>
    <span class="c">// 的 ticket - l.notify &lt; 0 时，它会立即触发条件而无需 </span>
    <span class="c">// 调用gopark 挂起自己.</span>
    <span class="c">//</span>
    <span class="c">// 在链表中找到与 t (此处一定要注意，是t而不是l.notfiy)</span>
    <span class="c">// 相等的sudog唤醒，并将其移除链表</span>
    <span class="c">// 需要说明的是，链表中的sudog顺序并不与ticket 顺序一致，</span>
    <span class="c">// 因为获取 ticket number与加入队列是割裂的。但总能保证</span>
    <span class="c">// 被唤醒的 g 是 ticket number == t 的，无论其此时是否</span>
    <span class="c">// 已经加入队列。</span>
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">sudog</span><span class="p">)(</span><span class="no">nil</span><span class="p">),</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span><span class="p">;</span> <span class="n">s</span> <span class="o">!=</span> <span class="no">nil</span><span class="p">;</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">next</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">ticket</span> <span class="o">==</span> <span class="n">t</span> <span class="p">{</span>
            <span class="n">n</span> <span class="o">:=</span> <span class="n">s</span><span class="o">.</span><span class="n">next</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
                <span class="n">p</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">n</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
                <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">p</span>
            <span class="p">}</span>
            <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="no">nil</span> <span class="c">// 取消next引用</span>
            <span class="n">readyWithTime</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span> <span class="c">// 唤醒对应的 g</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// runtime_notifyListNotifyOne 实现，在runtime/sema.go中，</span>
<span class="c">// 过linkname进行连接</span>
<span class="c">// runtime_notifyListNotifyAll 唤醒链表中所有的g.</span>
<span class="c">//go:linkname notifyListNotifyAll sync.runtime_notifyListNotifyAll</span>
<span class="k">func</span> <span class="n">notifyListNotifyAll</span><span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">notifyList</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Fast-path: 自从上一次通知发送后，没有新的waiter进入队列；</span>
    <span class="c">// 直接返回，不进入唤醒流程。</span>
    <span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">wait</span><span class="p">)</span> <span class="o">==</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">notify</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c">// 复制当前链表，并清空队列</span>
    <span class="n">lockWithRank</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">lockRankNotifyList</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">head</span>
    <span class="n">l</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="no">nil</span>
    <span class="n">l</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="no">nil</span>

    <span class="c">// 直接将l.wait赋值给l.notify</span>
    <span class="c">// 因为cond的机制总能保证 持有ticker number</span>
    <span class="c">// 的g 接收到对应通知，无论其是否在队列中</span>
    <span class="n">atomic</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">notify</span><span class="p">,</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">wait</span><span class="p">))</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>

    <span class="c">// 遍历列表，唤醒所有g</span>
    <span class="k">for</span> <span class="n">s</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">next</span> <span class="o">:=</span> <span class="n">s</span><span class="o">.</span><span class="n">next</span>
        <span class="n">s</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="no">nil</span>
        <span class="n">readyWithTime</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">next</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>golang的<code class="language-plaintext highlighter-rouge">sync.Cond</code>与<code class="language-plaintext highlighter-rouge">sync.Once</code>一样，它们的源码都很简单易读，可以说是模范代码。通过各种 <code class="language-plaintext highlighter-rouge">FastPath</code> 进行提前检查（Double Check 模式），从而避免过多的锁竞争，减少cpu的开销。</p>

<p>同时也应该注意到：所有在锁保护内外都有读写操作的变量，如果想使写入立即更新（无论操作是否在锁保护范围内）和读取最新的值（在锁保护范围外），最好通过atomic方法执行。</p>

<h3 id="reactor">Reactor</h3>

<p>反应堆模式：反应堆模式是一个事件驱动的并发模型，可以同时监听多个服务请求，通过<code class="language-plaintext highlighter-rouge">同步多路复用器（Synchronous Event Demultiplexer）</code>进行多路分解，将请求调度到对应的<code class="language-plaintext highlighter-rouge">Request Handler</code>。</p>

<p><strong>使用场景</strong>：多用于服务器程序中，用来监听外部链接请求和已建立链接发送的请求。</p>

<p>它主要由：</p>

<ul>
  <li>Resource：任何可以提供输入和消费输出的资源；</li>
  <li>Synchronous Event Demultiplexer：通过<code class="language-plaintext highlighter-rouge">event loop</code>的形式监听所有资源的<code class="language-plaintext highlighter-rouge">event</code>，当监听到资源的事件时候，它会将资源交给<code class="language-plaintext highlighter-rouge">Dispathcer</code>去调度执行对应的<code class="language-plaintext highlighter-rouge">Rquest Handler</code>；</li>
  <li>Dispatcher：管理<code class="language-plaintext highlighter-rouge">Request Handler</code>的注册与注销，从多路复用器处获取资源，并调用关联的<code class="language-plaintext highlighter-rouge">Rquest Handler</code>；</li>
  <li>Request Handler：包含用户定义的处理流程和它关联的资源；</li>
</ul>

<p>如下类图参照Pattern In C - Part 5:REACTOR的内容[4]：
<img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG4lJS1cbmNsYXNzIEhhbmRsZVxuJSUtXG5jbGFzcyBSZWFjdG9yIHtcbitSZWdpc3RlcigqUmVxdWVzdEhhbmRsZXIpXG4rVW5yZWdpc3RlcigqUmVxdWVzdEhhbmRsZXIpXG4rSGFuZGxlRXZlbnRzKClcbn1cbiUlLVxuY2xhc3MgUmVxdWVzdEhhbmRsZXJ7XG48PGludGVyZmFjZT4-XG4rIEhhbmRsZXJFdmVudCgpXG4rIEdldEhhbmRsZSgpIEhhbmRsZVxufVxuJSUtXG5jbGFzcyBDb250YWN0U2VydmVySGFuZGxlciB7XG4rIEhhbmRsZXJFdmVudCgpXG4rIEdldEhhbmRsZSgpIEhhbmRsZVxufVxuJSUtXG5jbGFzcyBDb250YWN0Q2xpZW50SGFuZGxlciB7XG4rIEhhbmRsZXJFdmVudCgpXG4rIEdldEhhbmRsZSgpIEhhbmRsZVxufVxuJSUtXG5Db250YWN0Q2xpZW50SGFuZGxlciAuLnw-IFJlcXVlc3RIYW5kbGVyXG5Db250YWN0U2VydmVySGFuZGxlciAuLnw-IFJlcXVlc3RIYW5kbGVyXG5SZWFjdG9yIFwiMVwiICotLSBcIjAuLipcIiBSZXF1ZXN0SGFuZGxlcjogZGlzcGF0Y2hlcyB0b1xuJSUtXG5SZWFjdG9yIC4uPiBIYW5kbGVcbkNvbnRhY3RTZXJ2ZXJIYW5kbGVyIC4uPiBIYW5kbGVcbkNvbnRhY3RDbGllbnRIYW5kbGVyIC4uPiBIYW5kbGUiLCJtZXJtYWlkIjpudWxsfQ"></p>

<p>上面的<code class="language-plaintext highlighter-rouge">Handle</code>就是<code class="language-plaintext highlighter-rouge">Resources</code>，它通常是一个系统资源的标识符（如：socket、file、devices等），可以通过poll、select、epoll 来监听事件（READ、WRITE、EXCEPTION等），基于event驱动的服务模型十分常见而且高效。</p>

<p>在golang中使用的<code class="language-plaintext highlighter-rouge">os.File</code>、<code class="language-plaintext highlighter-rouge">os.Connection</code>都是基于事件模型，它们都是基于一个关键结构<code class="language-plaintext highlighter-rouge">poller.FD</code>的封装。[5]</p>

<p>这里简单介绍一下golang中封装的基于事件的文件描述符操作模型(<strong>以linux版本为主</strong>)：</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// FD 文件描述符. 在net和os包中引用这个类型</span>
<span class="c">// 用于实现一个网络链接或系统文件类型 </span>
<span class="k">type</span> <span class="n">FD</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// 互斥锁，用于序列化读写方法调用；</span>
    <span class="n">fdmu</span> <span class="n">fdMutex</span>

    <span class="c">// 真正的系统分配的文件描述符，不可变</span>
    <span class="n">Sysfd</span> <span class="kt">int</span>

    <span class="c">// I/O poller.</span>
    <span class="n">pd</span> <span class="n">pollDesc</span>

    <span class="c">// Writev cache.</span>
    <span class="n">iovecs</span> <span class="o">*</span><span class="p">[]</span><span class="n">syscall</span><span class="o">.</span><span class="n">Iovec</span>

    <span class="c">// 文件关闭时接收到的信号</span>
    <span class="n">csema</span> <span class="kt">uint32</span>

    <span class="c">// 是否开启了block模式（非0表示开启）.</span>
    <span class="n">isBlocking</span> <span class="kt">uint32</span>

    <span class="c">// 是否为一个 streaming 描述符（如tcp），</span>
    <span class="c">// False 表示为一个 packet-based描述符（如udp）</span>
    <span class="c">// 不可变 </span>
    <span class="n">IsStream</span> <span class="kt">bool</span>

    <span class="c">// 读取返回零字节表示EOF</span>
    <span class="c">// Flase 表示当前为一个 message-based socket。</span>
    <span class="n">ZeroReadIsEOF</span> <span class="kt">bool</span>

    <span class="c">// 当前对应系统资源是否为 File 而不是 网络 socket。</span>
    <span class="n">isFile</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="c">// 初始化FD，此时Sysfd 应该已经被设置了.</span>
<span class="c">// net 参数可以传入一种网络链接协议（如 tcp、udp等）或者 "file".</span>
<span class="c">// pollable 为 true的时候 fd应该由 runtime netpoll来管理.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">fd</span> <span class="o">*</span><span class="n">FD</span><span class="p">)</span> <span class="n">Init</span><span class="p">(</span><span class="n">net</span> <span class="kt">string</span><span class="p">,</span> <span class="n">pollable</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c">// 此处不关心真正的网络协议类型.</span>
    <span class="k">if</span> <span class="n">net</span> <span class="o">==</span> <span class="s">"file"</span> <span class="p">{</span>
        <span class="n">fd</span><span class="o">.</span><span class="n">isFile</span> <span class="o">=</span> <span class="no">true</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">pollable</span> <span class="p">{</span>
        <span class="n">fd</span><span class="o">.</span><span class="n">isBlocking</span> <span class="o">=</span> <span class="m">1</span>
        <span class="k">return</span> <span class="no">nil</span>
    <span class="p">}</span>
    <span class="c">// 初始化 pollDesc，有可能会触发runtime.netpoll初始化</span>
    <span class="n">err</span> <span class="o">:=</span> <span class="n">fd</span><span class="o">.</span><span class="n">pd</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="c">// 如果没办法初始化runtime poller，就使用block模式.</span>
        <span class="n">fd</span><span class="o">.</span><span class="n">isBlocking</span> <span class="o">=</span> <span class="m">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">err</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">maxRW</span> <span class="o">=</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="m">30</span>

<span class="c">// Read 实现 了io.Reader接口.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">fd</span> <span class="o">*</span><span class="n">FD</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fd</span><span class="o">.</span><span class="n">readLock</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="m">0</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="n">fd</span><span class="o">.</span><span class="n">readUnlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// 如果传入的read buffer为0此处立即返回</span>
        <span class="c">// 否则 返回 0时， err = nil 等同于 io.EOF</span>
        <span class="c">// TODO(bradfitz): make it wait for readability? (Issue 15735)</span>
        <span class="k">return</span> <span class="m">0</span><span class="p">,</span> <span class="no">nil</span>
    <span class="p">}</span>
    <span class="c">// 准备读取</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fd</span><span class="o">.</span><span class="n">pd</span><span class="o">.</span><span class="n">prepareRead</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">isFile</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="m">0</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>
    <span class="c">// 对于 streaming fd，限制读取大小 1GB</span>
    <span class="k">if</span> <span class="n">fd</span><span class="o">.</span><span class="n">IsStream</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxRW</span> <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="o">:</span><span class="n">maxRW</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c">// 从 fd中读取数据，忽略EINTR 错误</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">ignoringEINTRIO</span><span class="p">(</span><span class="n">syscall</span><span class="o">.</span><span class="n">Read</span><span class="p">,</span> <span class="n">fd</span><span class="o">.</span><span class="n">Sysfd</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="n">n</span> <span class="o">=</span> <span class="m">0</span>
            <span class="c">// syscall.EAGAIN 资源暂时无效需要重试，</span>
            <span class="c">// 且pollDesc.runtimeCtx != 0</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="n">syscall</span><span class="o">.</span><span class="n">EAGAIN</span> <span class="o">&amp;&amp;</span> <span class="n">fd</span><span class="o">.</span><span class="n">pd</span><span class="o">.</span><span class="n">pollable</span><span class="p">()</span> <span class="p">{</span>
                <span class="c">// 等待文件可读</span>
                <span class="k">if</span> <span class="n">err</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">pd</span><span class="o">.</span><span class="n">waitRead</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">isFile</span><span class="p">);</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
                    <span class="k">continue</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">eofError</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">pollDesc</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">runtimeCtx</span> <span class="kt">uintptr</span> <span class="c">// runtime.pollDesc 指针</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">serverInit</span> <span class="n">sync</span><span class="o">.</span><span class="n">Once</span>

<span class="k">func</span> <span class="p">(</span><span class="n">pd</span> <span class="o">*</span><span class="n">pollDesc</span><span class="p">)</span> <span class="n">init</span><span class="p">(</span><span class="n">fd</span> <span class="o">*</span><span class="n">FD</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c">// 此处使用了 lazyInitial 的模式 </span>
    <span class="n">serverInit</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="n">runtime_pollServerInit</span><span class="p">)</span>
    <span class="c">// 注册sysfd事件监听到 netpoll</span>
    <span class="n">ctx</span><span class="p">,</span> <span class="n">errno</span> <span class="o">:=</span> <span class="n">runtime_pollOpen</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">Sysfd</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">errno</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">ctx</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
            <span class="n">runtime_pollUnblock</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
            <span class="n">runtime_pollClose</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">errnoErr</span><span class="p">(</span><span class="n">syscall</span><span class="o">.</span><span class="n">Errno</span><span class="p">(</span><span class="n">errno</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">runtimeCtx</span> <span class="o">=</span> <span class="n">ctx</span>
    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// 准备读取</span>
<span class="k">func</span> <span class="p">(</span><span class="n">pd</span> <span class="o">*</span><span class="n">pollDesc</span><span class="p">)</span> <span class="n">prepareRead</span><span class="p">(</span><span class="n">isFile</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="sc">'r'</span><span class="p">,</span> <span class="n">isFile</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">pd</span> <span class="o">*</span><span class="n">pollDesc</span><span class="p">)</span> <span class="n">prepare</span><span class="p">(</span><span class="n">mode</span> <span class="kt">int</span><span class="p">,</span> <span class="n">isFile</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">runtimeCtx</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span>
    <span class="p">}</span>
    <span class="c">// 检查并重置当前的runtimeCtx状态</span>
    <span class="c">// 如对应模式是否超时、是否发生错误(主要是针对rw）、</span>
    <span class="c">// 是否正在被关闭</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="n">runtime_pollReset</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">runtimeCtx</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">convertErr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">isFile</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">pd</span> <span class="o">*</span><span class="n">pollDesc</span><span class="p">)</span> <span class="n">waitRead</span><span class="p">(</span><span class="n">isFile</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="sc">'r'</span><span class="p">,</span> <span class="n">isFile</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">pd</span> <span class="o">*</span><span class="n">pollDesc</span><span class="p">)</span> <span class="n">wait</span><span class="p">(</span><span class="n">mode</span> <span class="kt">int</span><span class="p">,</span> <span class="n">isFile</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">runtimeCtx</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"waiting for unsupported file type"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="n">runtime_pollWait</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">runtimeCtx</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">convertErr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">isFile</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上述代码是fd的read过程，其依赖的runtime实现如下：</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// runtime_pollServerInit 的具体实现，位于runtime/netpoll.go</span>
<span class="c">//go:linkname poll_runtime_pollServerInit internal/poll.runtime_pollServerInit</span>
<span class="k">func</span> <span class="n">poll_runtime_pollServerInit</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">netpollGenericInit</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// runtime_pollOpen 的具体实现，位于runtime/netpoll.go</span>
<span class="c">//go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpen</span>
<span class="k">func</span> <span class="n">poll_runtime_pollOpen</span><span class="p">(</span><span class="n">fd</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">pollDesc</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pd</span> <span class="o">:=</span> <span class="n">pollcache</span><span class="o">.</span><span class="n">alloc</span><span class="p">()</span> <span class="c">// pollcache 是一个单向链表</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>
    <span class="c">// 检查读状态</span>
    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">wg</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">pd</span><span class="o">.</span><span class="n">wg</span> <span class="o">!=</span> <span class="n">pdReady</span> <span class="p">{</span>
        <span class="n">throw</span><span class="p">(</span><span class="s">"runtime: blocked write on free polldesc"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 检查写状态</span>
    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">rg</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">pd</span><span class="o">.</span><span class="n">rg</span> <span class="o">!=</span> <span class="n">pdReady</span> <span class="p">{</span>
        <span class="n">throw</span><span class="p">(</span><span class="s">"runtime: blocked read on free polldesc"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">closing</span> <span class="o">=</span> <span class="no">false</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">everr</span> <span class="o">=</span> <span class="no">false</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">rseq</span><span class="o">++</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">rg</span> <span class="o">=</span> <span class="m">0</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">rd</span> <span class="o">=</span> <span class="m">0</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">wseq</span><span class="o">++</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">wg</span> <span class="o">=</span> <span class="m">0</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">wd</span> <span class="o">=</span> <span class="m">0</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">self</span> <span class="o">=</span> <span class="n">pd</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>

    <span class="k">var</span> <span class="n">errno</span> <span class="kt">int32</span>
    <span class="c">// 添加事件监听</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="n">netpollopen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">pd</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// runtime_pollReset 的具体实现，位于runtime/netpoll.go </span>
<span class="c">// 对一个描述符的`r` 或 `w` 模式做准备</span>
<span class="c">//go:linkname poll_runtime_pollReset internal/poll.runtime_pollReset</span>
<span class="k">func</span> <span class="n">poll_runtime_pollReset</span><span class="p">(</span><span class="n">pd</span> <span class="o">*</span><span class="n">pollDesc</span><span class="p">,</span> <span class="n">mode</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c">// 检查当前的状态</span>
    <span class="n">errcode</span> <span class="o">:=</span> <span class="n">netpollcheckerr</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int32</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">errcode</span> <span class="o">!=</span> <span class="n">pollNoError</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">errcode</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="sc">'r'</span> <span class="p">{</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">rg</span> <span class="o">=</span> <span class="m">0</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="sc">'w'</span> <span class="p">{</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">wg</span> <span class="o">=</span> <span class="m">0</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pollNoError</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">netpollGenericInit</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpollInited</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpollInitLock</span><span class="p">,</span> <span class="n">lockRankNetpollInit</span><span class="p">)</span>
        <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpollInitLock</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">netpollInited</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
            <span class="c">// 执行对应操作平台的初始化</span>
            <span class="c">// linux 中是通过 epoll 实现</span>
            <span class="c">// darwin 中是通过 kqueue 实现</span>
            <span class="c">// windows 中是通过 Iocp（完成端口） 实现</span>
            <span class="n">netpollinit</span><span class="p">()</span> 
            <span class="n">atomic</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpollInited</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpollInitLock</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// runtime_pollWait, 的具体实现，位于runtime/netpoll.go,</span>
<span class="c">// 根据模式（r 或 w）,等待描述符可读或可写;</span>
<span class="c">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</span>
<span class="k">func</span> <span class="n">poll_runtime_pollWait</span><span class="p">(</span><span class="n">pd</span> <span class="o">*</span><span class="n">pollDesc</span><span class="p">,</span> <span class="n">mode</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c">// 检查当前的状态</span>
    <span class="n">errcode</span> <span class="o">:=</span> <span class="n">netpollcheckerr</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int32</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">errcode</span> <span class="o">!=</span> <span class="n">pollNoError</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">errcode</span>
    <span class="p">}</span>
    <span class="c">// 目前只有 Solaris, illumos, and AIX 使用 level-triggered IO.</span>
    <span class="k">if</span> <span class="n">GOOS</span> <span class="o">==</span> <span class="s">"solaris"</span> <span class="o">||</span> <span class="n">GOOS</span> <span class="o">==</span> <span class="s">"illumos"</span> <span class="o">||</span> <span class="n">GOOS</span> <span class="o">==</span> <span class="s">"aix"</span> <span class="p">{</span>
        <span class="n">netpollarm</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="o">!</span><span class="n">netpollblock</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int32</span><span class="p">(</span><span class="n">mode</span><span class="p">),</span> <span class="no">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errcode</span> <span class="o">=</span> <span class="n">netpollcheckerr</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int32</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">errcode</span> <span class="o">!=</span> <span class="n">pollNoError</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">errcode</span>
        <span class="p">}</span>
        <span class="c">// Can happen if timeout has fired and unblocked us,</span>
        <span class="c">// but before we had a chance to run, timeout has been reset.</span>
        <span class="c">// Pretend it has not happened and retry.</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pollNoError</span>
<span class="p">}</span>

<span class="c">// netpoll 初始化，linux 实现</span>
<span class="c">// 位于runtime/net_epoll.go</span>
<span class="k">func</span> <span class="n">netpollinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 创建一个epoll资源，</span>
    <span class="c">// 通过调用 syscall 291 epoll_create1(int flags)</span>
    <span class="c">// 取消子进程继承对该epoll实例的继承</span>
    <span class="n">epfd</span> <span class="o">=</span> <span class="n">epollcreate1</span><span class="p">(</span><span class="n">_EPOLL_CLOEXEC</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">epfd</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// 如果创建epoll实例创建不成功，</span>
        <span class="c">// 则 syscall 213 epoll_create(int size)，</span>
        <span class="c">// 从linux 2.6.8 后的内核对于size已经忽略了，</span>
        <span class="c">// 但是传入值必须大于0</span>
        <span class="n">epfd</span> <span class="o">=</span> <span class="n">epollcreate</span><span class="p">(</span><span class="m">1024</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">epfd</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
            <span class="nb">println</span><span class="p">(</span><span class="s">"runtime: epollcreate failed with"</span><span class="p">,</span> <span class="o">-</span><span class="n">epfd</span><span class="p">)</span>
            <span class="n">throw</span><span class="p">(</span><span class="s">"runtime: netpollinit failed"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c">// 取消子进程继承对该epoll实例的继承</span>
        <span class="c">// fcntl(fd, F_SETFD, FD_CLOEXEC)</span>
        <span class="n">closeonexec</span><span class="p">(</span><span class="n">epfd</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 创建一个非阻塞的读写管道，</span>
    <span class="c">// syscall 293 pipe2</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">errno</span> <span class="o">:=</span> <span class="n">nonblockingPipe</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">errno</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
        <span class="nb">println</span><span class="p">(</span><span class="s">"runtime: pipe failed with"</span><span class="p">,</span> <span class="o">-</span><span class="n">errno</span><span class="p">)</span>
        <span class="n">throw</span><span class="p">(</span><span class="s">"runtime: pipe failed"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 在epoll中注册监听 pipe Read 端的 read event</span>
    <span class="n">ev</span> <span class="o">:=</span> <span class="n">epollevent</span><span class="p">{</span>
        <span class="n">events</span><span class="o">:</span> <span class="n">_EPOLLIN</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">.</span><span class="n">data</span><span class="p">))</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">netpollBreakRd</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="n">epollctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">_EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">errno</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
        <span class="nb">println</span><span class="p">(</span><span class="s">"runtime: epollctl failed with"</span><span class="p">,</span> <span class="o">-</span><span class="n">errno</span><span class="p">)</span>
        <span class="n">throw</span><span class="p">(</span><span class="s">"runtime: epollctl failed"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">netpollBreakRd</span> <span class="o">=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">netpollBreakWr</span> <span class="o">=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">netpollopen</span><span class="p">(</span><span class="n">fd</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="n">pd</span> <span class="o">*</span><span class="n">pollDesc</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">ev</span> <span class="n">epollevent</span>
    <span class="c">// 监听 可读、可写、对端关闭连接或者shut down writing helf、</span>
    <span class="c">// 边缘触发通知（默认为 level-triggerd）  </span>
    <span class="n">ev</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">_EPOLLIN</span> <span class="o">|</span> <span class="n">_EPOLLOUT</span> <span class="o">|</span> <span class="n">_EPOLLRDHUP</span> <span class="o">|</span> <span class="n">_EPOLLET</span>
    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">pollDesc</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">.</span><span class="n">data</span><span class="p">))</span> <span class="o">=</span> <span class="n">pd</span>
    <span class="c">// 注册监听事件到 netpoll</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">epollctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">_EPOLL_CTL_ADD</span><span class="p">,</span> <span class="kt">int32</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">netpollcheckerr</span><span class="p">(</span><span class="n">pd</span> <span class="o">*</span><span class="n">pollDesc</span><span class="p">,</span> <span class="n">mode</span> <span class="kt">int32</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">closing</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">pollErrClosing</span>
    <span class="p">}</span>
    <span class="c">// 检查是否读写超时</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="sc">'r'</span> <span class="o">&amp;&amp;</span> <span class="n">pd</span><span class="o">.</span><span class="n">rd</span> <span class="o">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="sc">'w'</span> <span class="o">&amp;&amp;</span> <span class="n">pd</span><span class="o">.</span><span class="n">wd</span> <span class="o">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">pollErrTimeout</span>
    <span class="p">}</span>

    <span class="c">// 只有在读模式下会上报一个事件扫描错误</span>
    <span class="c">// 写事件错误会被随后的写入调用获取，</span>
    <span class="c">// 而且会上报更具体的错误</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="sc">'r'</span> <span class="o">&amp;&amp;</span> <span class="n">pd</span><span class="o">.</span><span class="n">everr</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">pollErrNotPollable</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pollNoError</span>
<span class="p">}</span>

<span class="c">// 如果IO处于 ready状态则返回 true，如果 timeout或者 closed 则返回false</span>
<span class="c">// waitio - 忽略错误，仅仅等待IO完成</span>
<span class="k">func</span> <span class="n">netpollblock</span><span class="p">(</span><span class="n">pd</span> <span class="o">*</span><span class="n">pollDesc</span><span class="p">,</span> <span class="n">mode</span> <span class="kt">int32</span><span class="p">,</span> <span class="n">waitio</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="n">gpp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">pd</span><span class="o">.</span><span class="n">rg</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="sc">'w'</span> <span class="p">{</span>
        <span class="n">gpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pd</span><span class="o">.</span><span class="n">wg</span>
    <span class="p">}</span>

    <span class="c">// 将pd对应的状态设置为 wait</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="n">old</span> <span class="o">:=</span> <span class="o">*</span><span class="n">gpp</span>
        <span class="k">if</span> <span class="n">old</span> <span class="o">==</span> <span class="n">pdReady</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">gpp</span> <span class="o">=</span> <span class="m">0</span>
            <span class="k">return</span> <span class="no">true</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">old</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
            <span class="n">throw</span><span class="p">(</span><span class="s">"runtime: double wait"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Casuintptr</span><span class="p">(</span><span class="n">gpp</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">pdWait</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// 需要在将 gpp 设置为 pdWait 后重新检查错误状态，这是必要的，</span>
    <span class="c">// 因为 runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl </span>
    <span class="c">// 做相反的事情：写数据到 closing/rd/wd 成员变量，membarrier，加载 rg/wg</span>
    <span class="k">if</span> <span class="n">waitio</span> <span class="o">||</span> <span class="n">netpollcheckerr</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// 挂起 g，并把 g 的地址赋值给 wg 或 rg。</span>
        <span class="n">gopark</span><span class="p">(</span><span class="n">netpollblockcommit</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">gpp</span><span class="p">),</span> <span class="n">waitReasonIOWait</span><span class="p">,</span> <span class="n">traceEvGoBlockNet</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// be careful to not lose concurrent pdReady notification</span>
    <span class="n">old</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Xchguintptr</span><span class="p">(</span><span class="n">gpp</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">old</span> <span class="o">&gt;</span> <span class="n">pdWait</span> <span class="p">{</span>
        <span class="n">throw</span><span class="p">(</span><span class="s">"runtime: corrupted polldesc"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">old</span> <span class="o">==</span> <span class="n">pdReady</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下面对<code class="language-plaintext highlighter-rouge">runtime.pollDesc</code>结构体进行一下简单的阐述：</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 位于runtime/netpoll.go 不要与上面的混淆 </span>
<span class="c">// Network poller 的描述.</span>
<span class="c">//go:notinheap</span>
<span class="k">type</span> <span class="n">pollDesc</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">link</span> <span class="o">*</span><span class="n">pollDesc</span> <span class="c">// in pollcache, protected by pollcache.lock</span>

    <span class="c">// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.</span>
    <span class="c">// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.</span>
    <span class="c">// pollReset, pollWait, pollWaitCanceled and runtime·netpollready (IO readiness notification)</span>
    <span class="c">// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated</span>
    <span class="c">// in a lock-free way by all operations.</span>
    <span class="c">// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),</span>
    <span class="c">// that will blow up when GC starts moving objects.</span>
    <span class="n">lock</span>    <span class="n">mutex</span> <span class="c">// 互斥锁，用于保护下面的字段</span>
    <span class="n">fd</span>      <span class="kt">uintptr</span> <span class="c">// 真正的文件描述符(由系统分配)，贯穿整个desc生命周期</span>
    <span class="n">closing</span> <span class="kt">bool</span>    <span class="c">// 正在关闭</span>
    <span class="n">everr</span>   <span class="kt">bool</span>      <span class="c">// epoll 监听到EPOLLERR事件</span>
    <span class="n">user</span>    <span class="kt">uint32</span>    <span class="c">// user settable cookie</span>
    <span class="n">rseq</span>    <span class="kt">uintptr</span>   <span class="c">// 防止过时的读定时器</span>
    <span class="n">rg</span>      <span class="kt">uintptr</span>   <span class="c">// 当前状态 pdReady, pdWait, 等待读取的 G 或者 nil</span>
    <span class="n">rt</span>      <span class="n">timer</span>     <span class="c">// 读取 deadline 定时器 (set if rt.f != nil)</span>
    <span class="n">rd</span>      <span class="kt">int64</span>     <span class="c">// 读取 deadline</span>
    <span class="n">wseq</span>    <span class="kt">uintptr</span>   <span class="c">// 防止过时的写定时器</span>
    <span class="n">wg</span>      <span class="kt">uintptr</span>   <span class="c">// pdReady, pdWait,  等待写入的 G or nil</span>
    <span class="n">wt</span>      <span class="n">timer</span>     <span class="c">// 写入 deadline 定时器</span>
    <span class="n">wd</span>      <span class="kt">int64</span>     <span class="c">// 写入 deadline</span>
    <span class="n">self</span>    <span class="o">*</span><span class="n">pollDesc</span> <span class="c">// storage for indirect interface. See (*pollDesc).makeArg.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>熟悉<code class="language-plaintext highlighter-rouge">epoll</code>和<code class="language-plaintext highlighter-rouge">edge-tiggerd</code>的读者可能更容易理解一些，在<code class="language-plaintext highlighter-rouge">edge-triggerd</code>下只有在状态发生切换的时候才会触发事件，即由<code class="language-plaintext highlighter-rouge">不可读</code>变为<code class="language-plaintext highlighter-rouge">可读</code>、<code class="language-plaintext highlighter-rouge">不可写</code>变为<code class="language-plaintext highlighter-rouge">可写</code>，而在数据未完全读取前不会再次触发<code class="language-plaintext highlighter-rouge">可读</code>事件。
所以这就是为什么在<code class="language-plaintext highlighter-rouge">read</code>的时候先进行循环读取，如果返回<code class="language-plaintext highlighter-rouge">EAGAIN</code>（无数据可读）时才执行<code class="language-plaintext highlighter-rouge">gopark</code>挂起 <code class="language-plaintext highlighter-rouge">g</code>，等待<code class="language-plaintext highlighter-rouge">可读</code>事件触发再通过<code class="language-plaintext highlighter-rouge">goready</code>唤醒 <code class="language-plaintext highlighter-rouge">g</code>。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiZmxvd2NoYXJ0IFREXG5TdGFydFtzdGFydF07XG5FbmRbZW5kXTtcblN5c1JlYWR7c3lzY2FsbCByZWFkIGRhdGEsIE9LP307XG5FcnJBZ2FpbntJcyBFQUdBSU4_fTtcbk5vRXJyb3J7IGVycm9yID09IG5pbD99XG5zdWJncmFwaCBwcmVwYXJlW25ldHBvbGxfcHJlcGFyZV1cbnByZV9zdGFydFtlbnRlcl0tLT5wcmVfY2hrZXJye25ldHBvbGxlciBubyBlcnJvcj99O1xucHJlX2Noa2Vyci0tPnx5ZXN8cHJlX3Jlc2V0W3Jlc2V0IHJlYWR5IHN0YXRlXTtcbnByZV9jaGtlcnItLT58bm98cHJlX3JldHVybltyZXR1cm5dO1xucHJlX3Jlc2V0LS0-cHJlX3JldHVybjtcbmVuZFxuc3ViZ3JhcGggd2FpdFtuZXRwb2xsX3dhaXRfcmVhZHldXG53YWl0X3N0YXJ0W2VudGVyXS0tPndhaXRfY2hrZXJyO1xud2FpdF9jaGtlcnJ7bmV0cG9sbGVyIG5vIGVycm9yP30tLT58eWVzfG5ldHBvbGxibG9ja3tpcyByZWFkeT99O1xud2FpdF9jaGtlcnItLT58bm98d2FpdF9yZXR1cm5bcmV0dXJuXTtcbm5ldHBvbGxibG9jay0tPnxub3x3YWl0X2Noa2Vycjtcbm5ldHBvbGxibG9jay0tPnxZZXN8d2FpdF9yZXR1cm47XG5lbmRcblN0YXJ0LS0-cHJlcGFyZTtwcmVwYXJlLS0-Tm9FcnJvcjtcbk5vRXJyb3ItLT58eWVzfFN5c1JlYWQ7Tm9FcnJvci0tPnxub3xFbmQ7XG5TeXNSZWFkLS0-fG5vfEVyckFnYWluO1N5c1JlYWQtLT58eWVzfEVuZDtcbkVyckFnYWluLS0-fHllc3x3YWl0O0VyckFnYWluLS0-fG5vfEVuZDtcbndhaXQtLT5Ob0Vycm9yOyIsIm1lcm1haWQiOm51bGx9"></p>

<p>如上面流程图所示，当<code class="language-plaintext highlighter-rouge">syscall read</code>返回<code class="language-plaintext highlighter-rouge">EAGAIN</code>的时候就会进入<code class="language-plaintext highlighter-rouge">netpoll_wait_ready</code>，有可能会导致挂起，那什么时候会唤醒呢？</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// netpoll 检查准备好的网络链接.</span>
<span class="c">// 返回可以执行的 g 列表</span>
<span class="c">// delay &lt; 0: 阻塞</span>
<span class="c">// delay == 0: 不阻塞</span>
<span class="c">// delay &gt; 0: 阻塞超时 delay ns</span>
<span class="k">func</span> <span class="n">netpoll</span><span class="p">(</span><span class="n">delay</span> <span class="kt">int64</span><span class="p">)</span> <span class="n">gList</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">epfd</span> <span class="o">==</span> <span class="o">-</span><span class="m">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">gList</span><span class="p">{}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="n">waitms</span> <span class="kt">int32</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">waitms</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">delay</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">waitms</span> <span class="o">=</span> <span class="m">0</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">delay</span> <span class="o">&lt;</span> <span class="m">1e6</span> <span class="p">{</span>
        <span class="n">waitms</span> <span class="o">=</span> <span class="m">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">delay</span> <span class="o">&lt;</span> <span class="m">1e15</span> <span class="p">{</span>
        <span class="n">waitms</span> <span class="o">=</span> <span class="kt">int32</span><span class="p">(</span><span class="n">delay</span> <span class="o">/</span> <span class="m">1e6</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c">// An arbitrary cap on how long to wait for a timer.</span>
        <span class="c">// 1e9 ms == ~11.5 days.</span>
        <span class="n">waitms</span> <span class="o">=</span> <span class="m">1e9</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="n">events</span> <span class="p">[</span><span class="m">128</span><span class="p">]</span><span class="n">epollevent</span>
<span class="n">retry</span><span class="o">:</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="n">epollwait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">events</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="kt">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)),</span> <span class="n">waitms</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="n">_EINTR</span> <span class="p">{</span>
            <span class="nb">println</span><span class="p">(</span><span class="s">"runtime: epollwait on fd"</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="s">"failed with"</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="p">)</span>
            <span class="n">throw</span><span class="p">(</span><span class="s">"runtime: netpoll failed"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c">// 如果 sleep 被中断，立即返回重新统计需要sleep的时间</span>
        <span class="k">if</span> <span class="n">waitms</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">gList</span><span class="p">{}</span>
        <span class="p">}</span>
        <span class="k">goto</span> <span class="n">retry</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="n">toRun</span> <span class="n">gList</span>
    <span class="c">// 遍历接收的事件</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="kt">int32</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">ev</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ev</span><span class="o">.</span><span class="n">events</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c">// 过滤netpollBreakRd读事件</span>
        <span class="k">if</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">.</span><span class="n">data</span><span class="p">))</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">netpollBreakRd</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">ev</span><span class="o">.</span><span class="n">events</span> <span class="o">!=</span> <span class="n">_EPOLLIN</span> <span class="p">{</span>
                <span class="nb">println</span><span class="p">(</span><span class="s">"runtime: netpoll: break fd ready for"</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
                <span class="n">throw</span><span class="p">(</span><span class="s">"runtime: netpoll: break fd ready for something unexpected"</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">delay</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
                <span class="c">// netpollBreak 用于打破poll的阻塞</span>
                <span class="c">// 通过向监听的 netpollBreakWr(pipe 写入端)</span>
                <span class="c">// 写入一byte数据，触发监听事件</span>
                <span class="k">var</span> <span class="n">tmp</span> <span class="p">[</span><span class="m">16</span><span class="p">]</span><span class="kt">byte</span>
                <span class="n">read</span><span class="p">(</span><span class="kt">int32</span><span class="p">(</span><span class="n">netpollBreakRd</span><span class="p">),</span> <span class="n">noescape</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">[</span><span class="m">0</span><span class="p">])),</span> <span class="kt">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
                <span class="n">atomic</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpollWakeSig</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="c">// 判断事件的模式（写入 或 读取）</span>
        <span class="k">var</span> <span class="n">mode</span> <span class="kt">int32</span>
        <span class="k">if</span> <span class="n">ev</span><span class="o">.</span><span class="n">events</span><span class="o">&amp;</span><span class="p">(</span><span class="n">_EPOLLIN</span><span class="o">|</span><span class="n">_EPOLLRDHUP</span><span class="o">|</span><span class="n">_EPOLLHUP</span><span class="o">|</span><span class="n">_EPOLLERR</span><span class="p">)</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
            <span class="n">mode</span> <span class="o">+=</span> <span class="sc">'r'</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">ev</span><span class="o">.</span><span class="n">events</span><span class="o">&amp;</span><span class="p">(</span><span class="n">_EPOLLOUT</span><span class="o">|</span><span class="n">_EPOLLHUP</span><span class="o">|</span><span class="n">_EPOLLERR</span><span class="p">)</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
            <span class="n">mode</span> <span class="o">+=</span> <span class="sc">'w'</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
            <span class="n">pd</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="n">pollDesc</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">everr</span> <span class="o">=</span> <span class="no">false</span>
            <span class="k">if</span> <span class="n">ev</span><span class="o">.</span><span class="n">events</span> <span class="o">==</span> <span class="n">_EPOLLERR</span> <span class="p">{</span> <span class="c">// 判断是否为错误类型事件</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">everr</span> <span class="o">=</span> <span class="no">true</span>
            <span class="p">}</span>
            <span class="c">// 根据对应的模式, 将 rg 或 wg 设置为 pReady模式，</span>
            <span class="c">// 将绑定在上面的 g 添加到 toRun 列表中</span>
            <span class="n">netpollready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">toRun</span><span class="p">,</span> <span class="n">pd</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">toRun</span>
<span class="p">}</span>
</code></pre></div></div>
<p>可以看到完全是依赖于系统提供的<code class="language-plaintext highlighter-rouge">epoll</code>能力，那<code class="language-plaintext highlighter-rouge">netpoll</code>在何时会被调用？主要在以下情况：</p>

<ul>
  <li>startTheWorld：启动世界，用于解除stopWorld的效果，此时会从<code class="language-plaintext highlighter-rouge">poll network</code> 处拉取所有可以运行的<code class="language-plaintext highlighter-rouge">goroutine</code>分配给处理器去运行；</li>
  <li>findrunnable：查找一个可运行的<code class="language-plaintext highlighter-rouge">goroutine</code>去执行，尝试从其他P的本地队列或全局队列窃取，或者从`poll network 处去获取；</li>
  <li>gcDrain：在执行一个idle模式的标记任务时，会有限检查当前是否有其他可执行的任务，此时会从 <code class="language-plaintext highlighter-rouge">poll network</code> 拉取所有可以运行的<code class="language-plaintext highlighter-rouge">goroutine</code>分配给处理器去运行；</li>
  <li>sysmon：wasm 上还没有线程，所以没有 sysmon，为此启动一个 m 去执行 sysmon （循环调用不会停止），里面会从 <code class="language-plaintext highlighter-rouge">poll network</code>拉取任务；</li>
</ul>

<p>上面对 <code class="language-plaintext highlighter-rouge">golang</code>的<code class="language-plaintext highlighter-rouge">network poll</code>读取和初始化流程做了一个简要的分析，它与<code class="language-plaintext highlighter-rouge">Rector</code>并发模式有些相似，实现了<code class="language-plaintext highlighter-rouge">Synchronous Event Demultiplexer</code>，将<code class="language-plaintext highlighter-rouge">fd</code>使用<code class="language-plaintext highlighter-rouge">runtime.PollDesc</code>进行封装，基于事件决定挂起和恢复对应的<code class="language-plaintext highlighter-rouge">g</code>。主要差别在于没有将响应事件的处理方法和<code class="language-plaintext highlighter-rouge">Resources</code>封装到一起。</p>

<h3 id="thread-local-storage">Thread-local storage</h3>

<p>线程本地存储模式：略</p>

<h2 id="参考链接">参考链接</h2>

<p>[1] mermaid. Class diagrams. April 28 2021, https://mermaid-js.github.io/mermaid/#/classDiagram</p>

<p>[2] wikipedia. Software design pattern. 18 February 2021,, https://en.wikipedia.org/wiki/Software_design_pattern</p>

<p>[3] wikipedia. Test-driven development. https://en.wikipedia.org/wiki/Test-driven_development</p>

<p>[4] Adam Petersen. Pattern In C - Part 5:REACTOR. 14 Jun 2021, https://www.adamtornhill.com/Patterns%20in%20C%205,%20REACTOR.pdf</p>

<p>[5] golang. poller.FD. 1 Oct 2020, https://github.com/golang/go/blob/go1.16.2/src/internal/poll/fd_unix.go#L17</p>

        
      </section>

      <footer class="page__meta">
        
        


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-06-15T00:00:00+08:00">June 15, 2021</time></p>


      </footer>

      <section class="page__share">
  

  <a href="https://twitter.com/intent/tweet?text=Design_pattern%20http%3A%2F%2Flocalhost%3A4000%2Fdesign_pattern%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fdesign_pattern%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fdesign_pattern%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/computer_boundary/" class="pagination--pager" title="Computer_boundary
">Previous</a>
    
    
      <a href="/redis_psync_protocol/" class="pagination--pager" title="Redis_psync_protocol
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You May Also Enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/dns/" rel="permalink">Dns
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          6 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/set_benchmark_analyse/" rel="permalink">Set_benchmark_analyse
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          12 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/redis_psync_protocol(1)/" rel="permalink">Redis_psync_protocol(1)
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          45 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/redis_psync_protocol/" rel="permalink">Redis_psync_protocol
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">© 2023 ZhipengWang. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
